<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Health Client Data Organizer</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        :root {
            --bg-main: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-container: white;
            --text-color-primary: #2c3e50;
            --text-color-secondary: #7f8c8d;
            --text-color-inverted: white;
            --panel-bg: #fafafa;
            --panel-border: #ecf0f1;
            --panel-footer-bg: #fdfdfd;
            --panel-header-bg: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            --item-bg: white;
            --item-active-bg: #e3f2fd;
            --item-border-color: #3498db;
            --item-active-border-color: #2196f3;
            --textarea-bg: white;
            --textarea-border: #ddd;
            --textarea-focus-border: #3498db;
            --textarea-focus-shadow: rgba(52, 152, 219, 0.2);
            --modal-bg: white;
            --modal-text: #333;
            --modal-header-border: #ccc;
            --input-bg: white;
            --input-text: #333;
            --input-border: #ccc;
            --suggestion-bg: #fff5f5;
            --suggestion-border: #e53e3e;
            --suggestion-text: #c53030;
            --resizer-bg: #ecf0f1;
            --deleted-item-text: #000;
        }

        [data-theme="dark"] {
            --bg-main: linear-gradient(135deg, #2c3e50 0%, #1a2533 100%);
            --bg-container: #2d3748;
            --text-color-primary: #e2e8f0;
            --text-color-secondary: #a0aec0;
            --text-color-inverted: #e2e8f0; /* Changed for better contrast on dark headers */
            --panel-bg: #283141;
            --panel-border: #4a5568;
            --panel-footer-bg: #232b38;
            --panel-header-bg: linear-gradient(135deg, #1a2533 0%, #2c3e50 100%);
            --item-bg: #4a5568;
            --item-active-bg: #718096;
            --item-border-color: #63b3ed;
            --item-active-border-color: #90cdf4;
            --appointment-item-active-bg: #5a4a63; /* Dark mode specific */
            --appointment-item-active-border: #c084fc; /* Dark mode specific */
            --textarea-bg: #2d3748;
            --textarea-border: #4a5568;
            --textarea-focus-border: #63b3ed;
            --textarea-focus-shadow: rgba(99, 179, 237, 0.3);
            --modal-bg: #2d3748;
            --modal-text: #e2e8f0;
            --modal-header-border: #4a5568;
            --input-bg: #4a5568;
            --input-text: #e2e8f0;
            --input-border: #718096;
            --suggestion-bg: #4c3030;
            --suggestion-border: #e53e3e;
            --suggestion-text: #fed7d7;
            --resizer-bg: #4a5568;
            --deleted-item-text: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 10px;
            overflow: hidden;
            color: var(--text-color-primary);
        }

        .container {
            width: 100%;
            margin: 0 auto;
            background: var(--bg-container);
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: var(--text-color-inverted);
            padding: 12px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin-right: auto;
        }

        .header-menu {
            position: relative;
            margin-left: 10px;
        }

        .header-menu-btn {
            background: linear-gradient(135deg, #7f8c8d 0%, #5d6d7e 100%);
        }

        .header-menu-dropdown {
            position: absolute;
            right: 0;
            top: calc(100% + 8px);
            min-width: 230px;
            background: var(--modal-bg);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 2000;
        }

        .menu-item-btn {
            width: 100%;
            text-align: left;
            justify-content: flex-start;
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: #fff;
            border: none;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .menu-item-btn.save {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .menu-item-btn.settings {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .menu-item-btn.theme {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.settings-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .btn.save-btn {
             background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .btn.theme-btn {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            padding: 0;
        }

        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        .panel {
            border-right: 2px solid var(--panel-border);
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-grow: 1; /* Allow panels to grow/shrink */
            flex-shrink: 1;
        }

        .panel:last-child {
            border-right: none;
        }
        
        .clients-panel { flex-basis: 20%; min-width: 180px; }
        .appointments-panel { flex-basis: 20%; min-width: 180px;}
        .session-panel { flex-basis: 30%; display: flex; flex-direction: column; min-width: 250px; }
        .soap-panel { flex-basis: 30%; min-width: 250px;}


        .panel-header {
            background: var(--panel-header-bg);
            color: var(--text-color-inverted);
            padding: 12px 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            height: 50px;
            min-height: 50px;
        }

        .add-btn {
            background: #27ae60;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .add-btn:hover {
            background: #229954;
            transform: scale(1.1);
        }
        
        .add-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .panel-footer {
            padding: 10px;
            border-top: 1px solid var(--panel-border);
            background: var(--panel-footer-bg);
            flex-shrink: 0;
        }
        
        input[type="date"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            background-color: var(--input-bg);
            color: var(--input-text);
        }

        /* Client Panel */
        .client-item {
            background: var(--item-bg);
            margin-bottom: 8px;
            padding: 12px;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s ease;
            border-left: 4px solid var(--item-border-color);
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            user-select: none;
        }
        .client-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .client-item.active {
            background: var(--item-active-bg);
            border-left-color: var(--item-active-border-color);
            font-weight: bold;
        }
        
        .client-item.dragging {
            opacity: 0.4;
            cursor: grabbing;
            transform: scale(0.97);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            z-index: 1000;
        }
        .client-item.drag-over-above {
            border-top: 3px solid var(--accent-color, #007aff);
            margin-top: -1px;
        }
        .client-item.drag-over-below {
            border-bottom: 3px solid var(--accent-color, #007aff);
            margin-bottom: 5px;
        }
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            opacity: 0.7;
            transform: scale(0.95);
            box-shadow: 0 8px 24px rgba(0,0,0,0.25);
            border-radius: 6px;
            transition: none;
        }
        body.dragging-active {
            user-select: none;
            -webkit-user-select: none;
            cursor: grabbing !important;
        }
        body.dragging-active * {
            user-select: none !important;
            -webkit-user-select: none !important;
        }
        
        .action-buttons {
            position: absolute;
            top: 5px; right: 5px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .client-item:hover .action-buttons, .appointment-item:hover .action-buttons, .note-item:hover .action-buttons, .intake-item:hover .action-buttons {
            opacity: 1;
        }
        .action-btn {
            border: none; color: white;
            width: 20px; height: 20px;
            border-radius: 50%;
            cursor: pointer; font-size: 12px;
            display: flex; align-items: center; justify-content: center;
        }
        .archive-btn { background: #f39c12; }
        .delete-btn { background: #e74c3c; }
        .edit-btn { background: #3498db; }
        .timeline-btn { background: #e67e22; }

        /* Appointments Panel */
        .appointment-item {
            background: var(--item-bg); margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #9b59b6; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .appointment-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .appointment-item.active {
            background: var(--appointment-item-active-bg, #f3e5f5);
            border-left-color: var(--appointment-item-active-border, #9c27b0);
        }
        .appointment-date { font-weight: 600; color: var(--text-color-primary); }

        .note-item {
            background: var(--item-bg); margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #16a085; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .note-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .note-item.active {
            background: #e8f8f5;
            border-left-color: #138d75;
        }
        [data-theme="dark"] .note-item.active {
            background: #2f4a45;
            border-left-color: #35c9a5;
        }
        .note-name { font-weight: 600; color: var(--text-color-primary); }
        .intake-item {
            background: var(--item-bg); margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #d35400; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .intake-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .intake-item.active {
            background: #fdf2e9;
            border-left-color: #ba4a00;
        }
        [data-theme="dark"] .intake-item.active {
            background: #4a3a2d;
            border-left-color: #f5b041;
        }
        .list-subheader {
            font-size: 0.8rem;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: var(--text-color-secondary);
            margin: 8px 0 6px;
            text-transform: uppercase;
        }

        /* Session and SOAP Panels */
        textarea {
            width: 100%; border: 1px solid var(--textarea-border); border-radius: 6px;
            padding: 12px; font-family: inherit; font-size: 14px;
            resize: both; /* Allow vertical and horizontal resizing */
            transition: all 0.2s;
            min-height: 50px; /* Ensure a minimum height */
            overflow: auto; /* Show scrollbars when content overflows */
            background-color: var(--textarea-bg);
            color: var(--text-color-primary);
        }
        textarea:focus {
            outline: none; border-color: var(--textarea-focus-border);
            box-shadow: 0 0 0 2px var(--textarea-focus-shadow);
        }
        
        .session-section {
            display: flex; flex-direction: column;
            flex-grow: 1; min-height: 0;
        }
        .session-section .panel-header {
             background: linear-gradient(135deg, #16a085 0%, #138d75 100%);
        }
        .session-section .panel-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        .session-section textarea {
            flex-grow: 1;
        }
        .persistent-notes-section .panel-header {
             background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        
        .goals-section .panel-header {
             background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
        }

        /* Collapsible Section Styles */
        .collapsible-header {
            cursor: pointer;
            user-select: none;
        }

        .collapsible-header:hover {
            opacity: 0.9;
        }

        .collapse-icon {
            transition: transform 0.3s ease;
            font-size: 0.8rem;
            margin-left: 8px;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .collapsible-content.collapsed {
            flex-basis: 50px !important;
            min-height: 50px !important;
            max-height: 50px !important;
            flex-grow: 0;
            flex-shrink: 0;
            overflow: hidden; /* Ensure no content spills over */
        }

        /* Pinning styles for collapsed sections */
        .collapsible-content.collapsed.pinned {
            order: 999; /* Pin to bottom */
        }

        /* Ensure wrapper containers also collapse properly */
        .session-section:has(.collapsible-content.collapsed) {
            flex-basis: 50px !important;
            min-height: 50px !important;
            max-height: 50px !important;
            flex-grow: 0;
            flex-shrink: 0;
        }

        .collapsible-content .panel-content {
            transition: opacity 0.2s ease;
        }

        .collapsible-content.collapsed .panel-content {
            opacity: 0;
            display: none;
        }

        /* Goals Section Scrolling */
        .goals-section .panel-content {
            overflow-y: auto;
            max-height: 100%;
        }

        /* Goals and Objectives Styling */
        .goal-item {
            background: var(--item-bg);
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #8e44ad;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .goal-title {
            font-weight: 600;
            color: var(--text-color-primary);
            flex-grow: 1;
            margin-right: 8px;
        }

        .goal-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .goal-item:hover .goal-actions {
            opacity: 1;
        }

        .goal-status {
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 8px;
        }

        .goal-status.active {
            background: #d4edda;
            color: #155724;
        }

        .goal-status.completed {
            background: #cce5ff;
            color: #004085;
        }

        .goal-status.discontinued {
            background: #f8d7da;
            color: #721c24;
        }

        .objective-list {
            margin-top: 8px;
            padding-left: 16px;
        }

        .objective-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .objective-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .objective-text {
            flex-grow: 1;
            color: var(--text-color-primary);
        }

        .objective-text.completed {
            text-decoration: line-through;
            color: var(--text-color-secondary);
        }

        .add-objective-btn {
            background: none;
            border: 1px dashed #8e44ad;
            color: #8e44ad;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-top: 8px;
            width: 100%;
        }

        .add-objective-btn:hover {
            background: rgba(142, 68, 173, 0.1);
        }

        .generator-card {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            background: var(--panel-bg);
        }
        .generator-title {
            font-weight: 700;
            margin-bottom: 6px;
        }
        .mini-input {
            width: 100%;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            padding: 7px;
            background: var(--input-bg);
            color: var(--input-text);
            font-family: inherit;
            font-size: 13px;
        }
        .intervention-list {
            max-height: 45vh;
            overflow-y: auto;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 8px;
            background: var(--panel-bg);
        }
        .intervention-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            border-bottom: 1px dashed var(--panel-border);
            font-size: 0.92rem;
        }
        .intervention-row:last-child {
            border-bottom: none;
        }
        .goal-generator-modal {
            width: 99.5vw;
            max-width: 1760px;
            max-height: 92vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .goal-generator-card {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            padding: 12px;
        }
        .goal-generator-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-color-secondary);
            margin-bottom: 8px;
            letter-spacing: 0.2px;
        }
        .setting-input {
            width: 100%;
            box-sizing: border-box;
        }
        .goal-generator-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        .goal-generator-secondary {
            display: grid;
            grid-template-columns: 140px 180px 220px;
            gap: 12px;
            align-items: end;
        }
        .goal-generator-secondary label {
            font-size: 0.9rem;
            font-weight: 600;
        }
        .goal-generator-secondary .setting-input {
            font-size: 0.9rem;
            padding: 7px 8px;
        }
        .goal-generator-modal label {
            font-size: 0.9rem;
        }
        .goal-generator-modal .setting-input {
            font-size: 0.9rem;
        }
        .goal-generator-modal .modality-row-btn {
            font-size: 0.9rem;
        }
        .goal-generator-actions {
            display: flex;
            gap: 10px;
            position: sticky;
            bottom: 0;
            background: var(--modal-bg);
            padding-top: 8px;
            z-index: 3;
        }
        #generatedGoalsReview {
            border-radius: 10px;
            padding: 10px;
            max-height: none !important;
            overflow: visible !important;
        }
        #generatedGoalsReview .generator-card {
            border-radius: 10px;
            padding: 12px;
        }
        .modality-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }
        .modality-option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: var(--text-color-primary);
        }
        .modality-row {
            display: grid;
            grid-template-columns: 1fr 34px 34px;
            gap: 8px;
            align-items: center;
        }
        .modality-row-btn {
            width: 34px;
            height: 34px;
            border-radius: 6px;
            border: 1px solid var(--panel-border);
            background: var(--panel-bg);
            color: var(--text-color-primary);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 700;
            line-height: 1;
        }
        .modality-row-btn:hover {
            background: var(--suggestion-bg);
        }

        .soap-section { margin-bottom: 15px; }
        .soap-header {
            background: linear-gradient(135deg, #5D6D7E 0%, #34495E 100%);
            color: var(--text-color-inverted); padding: 8px 12px;
            border-radius: 6px 6px 0 0; font-weight: 600;
            display: flex; justify-content: space-between; align-items: center;
        }
        .copy-btn {
            background: rgba(255, 255, 255, 0.2); border: none; color: var(--text-color-inverted);
            padding: 4px 8px; border-radius: 4px; cursor: pointer;
            font-size: 12px; transition: all 0.2s;
        }
        .copy-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .soap-textarea {
            border-radius: 0 0 6px 6px; border-top: none;
            flex-grow: 1;
            /* overflow-y: hidden; is removed to allow manual resize */
        }

        .suggestion-box {
            background-color: var(--suggestion-bg);
            border: 1px solid var(--suggestion-border);
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-size: 14px;
        }
        .suggestion-text {
            color: var(--suggestion-text);
            margin-bottom: 8px;
        }
        .suggestion-actions button {
            background: none;
            border: 1px solid;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-right: 5px;
        }
        .suggestion-accept { color: #27ae60; border-color: #27ae60; }
        .suggestion-accept-replace { color: #27ae60; border-color: #27ae60; }
        .suggestion-decline { color: #e74c3c; border-color: #e74c3c; }

        .audit-box {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 10px;
            background: var(--panel-bg);
            margin-top: 8px;
        }
        .audit-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .audit-badge {
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 0.78rem;
        }
        .audit-badge.pass {
            background: #d1fae5;
            color: #065f46;
        }
        .audit-badge.fail {
            background: #fee2e2;
            color: #991b1b;
        }
        [data-theme="dark"] .audit-badge.pass {
            background: #1f4438;
            color: #a7f3d0;
        }
        [data-theme="dark"] .audit-badge.fail {
            background: #4b2a2a;
            color: #fecaca;
        }
        .audit-items {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.86rem;
        }
        .audit-item-pass { color: #1f7a57; }
        .audit-item-fail { color: #c0392b; }
        .audit-remediation {
            margin-top: 10px;
            font-size: 0.84rem;
            color: var(--text-color-secondary);
        }
        .audit-remediation ul {
            margin: 6px 0 0 18px;
            padding: 0;
        }
        .audit-proofing-block {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--panel-border);
        }
        #regularSessionFields {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
            overflow-y: auto;
        }
        #sessionInfo {
            width: 100%;
            height: 20lh;
            min-height: 20lh;
            resize: vertical;
            flex: 0 0 auto;
        }
        .audit-proofing-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }
        .audit-proofing-field label {
            font-size: 0.8rem;
            color: var(--text-color-secondary);
            font-weight: 600;
            display: block;
            margin-bottom: 4px;
        }
        .audit-proofing-field textarea {
            min-height: 80px;
            resize: vertical;
        }

        .no-selection {
            color: var(--text-color-secondary); text-align: center;
            margin-top: 50px; font-style: italic;
        }
        .autosave-indicator { color: var(--text-color-inverted); font-size: 12px; margin-left: auto; }
        
        .deleted-list { max-height: 100px; overflow-y: auto; }
        .deleted-item { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; padding: 2px 0; color: var(--deleted-item-text); }
        .restore-btn {
             background: #3498db; color: white; border: none;
             padding: 2px 6px; border-radius: 4px; cursor: pointer;
        }
        .clear-deleted-btn {
            background: #e74c3c; color: white; border: none;
            padding: 2px 6px; border-radius: 4px; cursor: pointer;
            width: 100%; margin-top: 5px;
        }

        .resizer {
            background: var(--resizer-bg);
            cursor: col-resize;
            width: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        .resizer-y {
            background: var(--resizer-bg);
            cursor: row-resize;
            height: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--modal-bg);
            padding: 24px;
            border-radius: 12px;
            width: 100%;
            max-width: 512px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            position: relative; /* For the close button */
            color: var(--modal-text);
        }

        .modal-content.goal-generator-modal {
            width: min(99vw, 1940px);
            max-width: min(99vw, 1940px);
        }

        .guide-modal-content {
            max-width: min(980px, 92vw);
            max-height: 88vh;
            display: flex;
            flex-direction: column;
        }

        .guide-scroll {
            overflow-y: auto;
            line-height: 1.55;
            padding-right: 6px;
        }

        .guide-scroll h3 {
            margin: 1rem 0 0.5rem;
            font-size: 1.15rem;
        }

        .guide-scroll h4 {
            margin: 0.75rem 0 0.4rem;
            font-size: 1rem;
        }

        .guide-scroll ul {
            margin: 0.4rem 0 0.8rem 1.2rem;
        }

        .guide-scroll li {
            margin-bottom: 0.3rem;
        }

        .guide-callout {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-left: 4px solid var(--item-border-color);
            border-radius: 8px;
            padding: 10px 12px;
            margin: 0.75rem 0;
        }

        .guide-example {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 0.6rem;
        }

        .guide-checklist {
            list-style: none;
            margin-left: 0;
        }

        /* CSSRS Modal Styling (scoped) */
        #cssrsModal {
            --cssrs-border: #111;
            --cssrs-gray: #d9d9d9;
            --cssrs-yellow: #fff36a;
            --cssrs-orange: #f6b21a;
            --cssrs-red: #e97d7a;
            --cssrs-ink: #000;
        }
        #cssrsModal .modal-content {
            background: #f5f5f5;
            color: var(--cssrs-ink);
            padding: 14px;
        }
        #cssrsModal .wrap {
            max-width: 720px;
            margin: 16px auto;
            padding: 0 9px 20px;
        }
        #cssrsModal .card {
            background: #fff;
            border: 2px solid var(--cssrs-border);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }
        #cssrsModal .titlebar {
            background: var(--cssrs-gray);
            border-bottom: 2px solid var(--cssrs-border);
            font-weight: 900;
            font-size: 18px;
            letter-spacing: 0.5px;
            padding: 8px 9px;
            text-align: left;
        }
        #cssrsModal table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        #cssrsModal td,
        #cssrsModal th {
            border: 2px solid var(--cssrs-border);
            vertical-align: top;
            padding: 10px;
            color: var(--cssrs-ink);
        }
        #cssrsModal .topbar {
            background: var(--cssrs-gray);
            font-weight: 700;
            font-size: 14px;
            padding: 6px;
        }
        #cssrsModal .topbar-right {
            text-align: center;
            font-weight: 700;
            width: 20%;
            font-size: 12px;
        }
        #cssrsModal .qcell {
            font-size: 18px;
            font-weight: 800;
            line-height: 1.12;
        }
        #cssrsModal .qnum {
            font-weight: 900;
            margin-right: 6px;
        }
        #cssrsModal .instr {
            background: var(--cssrs-gray);
            font-size: 16px;
            font-weight: 700;
            line-height: 1.25;
        }
        #cssrsModal .risk {
            text-align: center;
            font-weight: 900;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 66px;
        }
        #cssrsModal .risk.yellow {
            background: var(--cssrs-yellow);
        }
        #cssrsModal .risk.orange {
            background: var(--cssrs-orange);
        }
        #cssrsModal .risk.red {
            background: var(--cssrs-red);
        }
        #cssrsModal .subhdr {
            background: var(--cssrs-gray);
            font-weight: 900;
            font-size: 15px;
            padding: 6px;
        }
        #cssrsModal .minihead {
            background: #fff;
            font-weight: 900;
            text-align: center;
            font-size: 14px;
            padding: 8px 6px;
        }
        #cssrsModal .q6text {
            font-size: 20px;
            font-weight: 900;
            line-height: 1.12;
        }
        #cssrsModal .examples {
            font-size: 14px;
            font-style: italic;
            margin-top: 8px;
            line-height: 1.25;
            font-weight: 600;
        }
        #cssrsModal .follow {
            font-size: 16px;
            font-weight: 900;
            margin-top: 8px;
        }
        #cssrsModal .risk select {
            width: 100%;
            min-width: 0;
            text-align: center;
            font-weight: 900;
        }
        #cssrsModal .q6right {
            padding: 0;
            height: 100%;
            position: relative;
        }
        #cssrsModal .q6row,
        #cssrsModal .q6row > td {
            height: 100%;
        }
        #cssrsModal .q6grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr;
            position: absolute;
            inset: 0;
            align-items: stretch;
        }
        #cssrsModal .q6rightcol {
            border-left: 2px solid var(--cssrs-border);
        }
        #cssrsModal .q6body {
            border-top: 2px solid var(--cssrs-border);
            height: 100%;
        }
        #cssrsModal .risk-indicator {
            margin-top: 14px;
            border-top: 2px solid var(--cssrs-border);
            padding: 12px 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: #fff;
        }
        #cssrsModal .risk-pill {
            padding: 8px 12px;
            border: 2px solid var(--cssrs-border);
            font-weight: 900;
            min-width: 120px;
            text-align: center;
        }
        #cssrsModal .risk-pill.low {
            background: var(--cssrs-yellow);
        }
        #cssrsModal .risk-pill.mod {
            background: var(--cssrs-orange);
        }
        #cssrsModal .risk-pill.high {
            background: var(--cssrs-red);
        }
        #cssrsModal .risk-note {
            font-size: 14px;
            font-weight: 700;
        }
        #cssrsModal .answers {
            margin-top: 18px;
            background: #fff;
            border: 2px solid var(--cssrs-border);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            padding: 14px;
        }
        #cssrsModal .answers h2 {
            margin: 0 0 10px;
            font-size: 18px;
            color: var(--cssrs-ink);
        }
        #cssrsModal #cssrs_compiled {
            width: 100%;
            min-height: 190px;
            border: 2px solid #222;
            border-radius: 10px;
            padding: 10px;
            font-size: 14px;
            line-height: 1.35;
            resize: vertical;
            box-sizing: border-box;
            background: #fff;
            color: #000;
        }
        #cssrsModal .btnrow {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        #cssrsModal .btnrow button {
            border: 2px solid #111;
            background: #fff;
            border-radius: 10px;
            padding: 10px 12px;
            font-weight: 900;
            cursor: pointer;
            color: #000;
            box-shadow: none;
            transform: none;
        }
        #cssrsModal .btnrow button:active {
            transform: translateY(1px);
        }
        #cssrsModal .status {
            font-size: 13px;
            font-weight: 800;
            color: #000;
        }
        #cssrsModal select,
        #cssrsModal input[type="text"] {
            font-size: 14px;
            padding: 8px 10px;
            border: 2px solid #222;
            border-radius: 8px;
            background: #fff;
            min-width: 170px;
            color: #000;
        }
        #cssrsModal #closeCssrsBtn {
            color: #111;
            line-height: 1;
            font-weight: 700;
        }

        @media (max-width: 760px) {
            #cssrsModal .qcell {
                font-size: 20px;
            }
            #cssrsModal .q6text {
                font-size: 22px;
            }
            #cssrsModal .risk-indicator {
                flex-direction: column;
                align-items: flex-start;
            }
        }


    </style>
</head>
<body data-theme="light">
    <!-- Rename Modal -->
    <div id="renameModal" class="modal-overlay hidden">
        <div class="modal-content" style="max-width: 400px;">
            <h3 id="renameModalTitle" style="margin-bottom: 16px; color: var(--text-color-primary);">Rename</h3>
            <input type="text" id="renameModalInput" style="width: 100%; padding: 10px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px; margin-bottom: 16px;">
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button id="renameModalCancel" class="btn" style="padding: 8px 16px; background: var(--panel-bg); color: var(--text-color-primary); border: 1px solid var(--input-border);">Cancel</button>
                <button id="renameModalConfirm" class="btn" style="padding: 8px 16px;">Save</button>
            </div>
        </div>
    </div>

    <!-- Login Overlay -->
    <div id="loginOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-main); z-index: 9999; overflow-y: auto; display: flex; text-align: center; justify-content: center; align-items: flex-start; padding: 20px;">
        <div style="background: var(--panel-bg); padding: 40px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); text-align: center; width: 400px; margin: auto;">
            <h2 id="loginTitle" style="margin-bottom: 20px; color: var(--text-color-primary);">Client Records Login</h2>
            <p id="loginSubtitle" style="margin-bottom: 20px; color: var(--text-color-secondary); font-size: 0.9rem;">Enter your username and password to unlock the database.</p>
            <input type="text" id="loginUsernameInput" placeholder="Username" style="width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 16px;">
            <input type="password" id="loginPasswordInput" placeholder="Password" style="width: 100%; padding: 12px; margin-bottom: 20px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 16px;">
            <div id="onboardingRecoverySection" style="display:none; text-align:left; margin-bottom:12px;">
                <input type="email" id="onboardingEmailInput" placeholder="Recovery Email" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <div style="font-size: 0.8rem; color: var(--text-color-secondary); margin-bottom: 6px; font-weight: 600;">SMTP Settings (for in-app password recovery)</div>
                <input type="text" id="onboardingSmtpHostInput" placeholder="SMTP Host (e.g., smtp.gmail.com)" value="smtp.gmail.com" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="number" id="onboardingSmtpPortInput" placeholder="SMTP Port (e.g., 587)" value="587" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <select id="onboardingSmtpSecurityInput" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                    <option value="starttls" selected>STARTTLS</option>
                    <option value="tls">TLS</option>
                    <option value="ssl">SSL</option>
                </select>
                <input type="text" id="onboardingSmtpUsernameInput" placeholder="SMTP Username" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="password" id="onboardingSmtpPasswordInput" placeholder="SMTP Password / App Password" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="email" id="onboardingSmtpFromInput" placeholder="From Email (optional)" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <div style="font-size: 0.75rem; color: var(--text-color-secondary);">Use an app password for Gmail/Outlook when required.</div>
            </div>
            <button id="loginBtn" class="btn" style="width: 100%; padding: 12px; font-size: 16px;">Unlock</button>
            <button id="forgotPasswordBtn" class="btn" style="width: 100%; padding: 10px; margin-top: 8px; background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Forgot Password?</button>
            <div id="loginToolsMenu" style="position: relative; margin-top: 8px;">
                <button id="loginToolsBtn" class="btn" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #5d6d7e 0%, #34495e 100%);">Account Tools â–¾</button>
                <div id="loginToolsDropdown" class="hidden" style="position:absolute; right:0; top:calc(100% + 6px); width:100%; background: var(--panel-bg); border:1px solid var(--panel-border); border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,0.2); padding:8px; z-index:10001;">
                    <button id="openSmtpPanelBtn" class="btn" style="width:100%; padding:10px; margin-bottom:8px; background: linear-gradient(135deg, #2980b9 0%, #1f5f8b 100%);">Update SMTP Settings</button>
                    <button id="openDeleteAccountPanelBtn" class="btn" style="width:100%; padding:10px; background: linear-gradient(135deg, #c0392b 0%, #922b21 100%);">Delete Account</button>
                </div>
            </div>
            <div id="resetPanel" style="display:none; text-align:left; margin-top: 12px; border: 1px solid var(--panel-border); border-radius: 8px; padding: 10px;">
                <div style="font-size: 0.85rem; font-weight: 700; margin-bottom: 8px; color: var(--text-color-primary);">Password Recovery</div>
                <input type="text" id="resetUsernameInput" placeholder="Username" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <button id="sendResetCodeBtn" class="btn" style="width: 100%; padding: 10px; margin-bottom: 8px;">Send Reset Code</button>
                <input type="text" id="resetCodeInput" placeholder="6-digit code" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="password" id="resetNewPasswordInput" placeholder="New Password" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="password" id="resetConfirmPasswordInput" placeholder="Confirm New Password" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <button id="confirmResetBtn" class="btn save-btn" style="width: 100%; padding: 10px; margin-bottom: 8px;">Reset Password</button>
                <button id="cancelResetBtn" class="btn" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);">Cancel</button>
                <div id="resetStatusMsg" style="font-size: 0.8rem; margin-top: 8px; color: var(--text-color-secondary);"></div>
            </div>
            <div id="verifyEmailPanel" style="display:none; text-align:left; margin-top: 12px; border: 1px solid #2980b9; border-radius: 8px; padding: 10px; background: rgba(41,128,185,0.06);">
                <div style="font-size: 0.85rem; font-weight: 700; margin-bottom: 8px; color: #2980b9;">Email Verification</div>
                <div style="font-size: 0.78rem; color: var(--text-color-secondary); margin-bottom: 8px;">Enter the 6-digit verification code sent to your account email.</div>
                <button id="sendVerifyEmailCodeBtn" class="btn" style="width: 100%; padding: 10px; margin-bottom: 8px;">Resend Verification Code</button>
                <input type="text" id="verifyEmailCodeInput" placeholder="6-digit verification code" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <button id="confirmVerifyEmailBtn" class="btn save-btn" style="width: 100%; padding: 10px; margin-bottom: 8px;">Verify Email</button>
                <button id="openSmtpPanelFromVerifyBtn" class="btn" style="width: 100%; padding: 10px; margin-bottom: 8px; background: linear-gradient(135deg, #2980b9 0%, #1f5f8b 100%);">Update SMTP Settings</button>
                <button id="cancelVerifyEmailBtn" class="btn" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);">Cancel</button>
                <div id="verifyEmailStatusMsg" style="font-size: 0.8rem; margin-top: 8px; color: var(--text-color-secondary);"></div>
            </div>
            <div id="smtpSettingsPanel" style="display:none; text-align:left; margin-top: 12px; border: 1px solid #2980b9; border-radius: 8px; padding: 10px; background: rgba(41,128,185,0.05); max-height: 400px; overflow-y: auto;">
                <div style="font-size: 0.85rem; font-weight: 700; margin-bottom: 8px; color: #2980b9;">Update Recovery SMTP Settings</div>
                <div style="font-size: 0.78rem; color: var(--text-color-secondary); margin-bottom: 8px;">Use your existing username/password to update recovery email and SMTP config.</div>
                <input type="text" id="smtpUpdateUsernameInput" placeholder="Username" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="password" id="smtpUpdatePasswordInput" placeholder="Password" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="email" id="smtpUpdateRecoveryEmailInput" placeholder="Recovery Email" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="text" id="smtpUpdateHostInput" placeholder="SMTP Host (e.g. smtp.gmail.com)" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="number" id="smtpUpdatePortInput" placeholder="SMTP Port (e.g. 587)" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <select id="smtpUpdateSecurityInput" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                    <option value="starttls" selected>STARTTLS</option>
                    <option value="tls">TLS</option>
                    <option value="ssl">SSL</option>
                </select>
                <input type="text" id="smtpUpdateUsernameSmtpInput" placeholder="SMTP Username" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="password" id="smtpUpdatePasswordSmtpInput" placeholder="SMTP Password / App Password" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="email" id="smtpUpdateFromInput" placeholder="From Email (optional)" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <button id="testSmtpSettingsBtn" class="btn" style="width:100%; padding:10px; margin-bottom:8px; background: linear-gradient(135deg, #16a085 0%, #117864 100%);">Send Test Email</button>
                <button id="saveSmtpSettingsBtn" class="btn save-btn" style="width:100%; padding:10px; margin-bottom:8px;">Save SMTP Settings</button>
                <button id="cancelSmtpSettingsBtn" class="btn" style="width:100%; padding:10px; background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);">Cancel</button>
                <div id="smtpSettingsStatusMsg" style="font-size: 0.8rem; margin-top: 8px; color: var(--text-color-secondary);"></div>
            </div>
            <div id="deleteAccountPanel" style="display:none; text-align:left; margin-top: 12px; border: 1px solid #c0392b; border-radius: 8px; padding: 10px; background: rgba(192,57,43,0.06);">
                <div style="font-size: 0.85rem; font-weight: 700; margin-bottom: 8px; color: #c0392b;">Delete Account (Permanent)</div>
                <div style="font-size: 0.78rem; color: var(--text-color-secondary); margin-bottom: 8px;">This permanently deletes the account and encrypted state on this device.</div>
                <input type="text" id="deleteAccountUsernameInput" placeholder="Username" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="password" id="deleteAccountPasswordInput" placeholder="Password" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="text" id="deleteAccountConfirmUsernameInput" placeholder="Type username again" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <input type="text" id="deleteAccountTypedWordInput" placeholder="Type DELETE ACCOUNT" style="width: 100%; padding: 10px; margin-bottom: 8px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--input-bg); color: var(--input-text); font-size: 14px;">
                <button id="confirmDeleteAccountBtn" class="btn" style="width: 100%; padding: 10px; margin-bottom: 8px; background: linear-gradient(135deg, #c0392b 0%, #922b21 100%);">Permanently Delete</button>
                <button id="cancelDeleteAccountBtn" class="btn" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);">Cancel</button>
                <div id="deleteAccountStatusMsg" style="font-size: 0.8rem; margin-top: 8px; color: var(--text-color-secondary);"></div>
            </div>
            <p id="loginErrorMsg" style="color: #e74c3c; margin-top: 15px; font-size: 0.9rem; display: none;">Incorrect username or password.</p>
        </div>
        </div>


    <!-- CSSRS Modal (moved to end of body for proper initialization) -->
    <div id="cssrsModal" class="modal-overlay hidden" tabindex="-1">
        <div class="modal-content" style="max-width:760px; width:95vw;">
            <button id="closeCssrsBtn" style="position:absolute; top:10px; right:10px; font-size:22px; background:none; border:none; cursor:pointer;">&times;</button>
            <div class="wrap" style="max-width:720px; margin:16px auto; padding:0 9px 20px;">
                <div class="card" role="region" aria-label="CSSRS">
                    <div class="titlebar">CSSRS</div>
                    <table aria-label="CSSRS table">
                        <colgroup>
                            <col style="width: 80%">
                            <col style="width: 20%">
                        </colgroup>
                        <tr>
                            <td class="topbar">Always ask questions 1 and 2.</td>
                            <td class="topbar topbar-right">Past Month</td>
                        </tr>
                        <tr>
                            <td><div class="qcell"><span class="qnum">1)</span>Have you wished you were dead or wished you could go to sleep and not wake up?</div></td>
                            <td class="risk yellow" aria-label="Past Month color block">
                                <select id="cssrs_q1" aria-label="Question 1 answer"><option value=""></option><option value="YES">YES</option><option value="NO">NO</option></select>
                            </td>
                        </tr>
                        <tr>
                            <td><div class="qcell"><span class="qnum">2)</span>Have you actually had any thoughts about killing yourself?</div></td>
                            <td class="risk yellow" aria-label="Past Month color block">
                                <select id="cssrs_q2" aria-label="Question 2 answer"><option value=""></option><option value="YES">YES</option><option value="NO">NO</option></select>
                            </td>
                        </tr>
                        <tr>
                            <td class="instr" colspan="2">If <strong>YES</strong> to 2, ask questions 3, 4, 5 and 6.<br/>If <strong>NO</strong> to 2, skip to question 6.</td>
                        </tr>
                        <tr>
                            <td><div class="qcell"><span class="qnum">3)</span>Have you been thinking about how you might do this?</div></td>
                            <td class="risk orange" aria-label="Past Month orange block">
                                <select id="cssrs_q3" aria-label="Question 3 answer"><option value=""></option><option value="YES">YES</option><option value="NO">NO</option></select>
                            </td>
                        </tr>
                        <tr>
                            <td><div class="qcell"><span class="qnum">4)</span>Have you had these thoughts and had some intention of acting on them?</div></td>
                            <td class="risk red" aria-label="High Risk">
                                <select id="cssrs_q4" aria-label="Question 4 answer"><option value=""></option><option value="YES">YES</option><option value="NO">NO</option></select>
                            </td>
                        </tr>
                        <tr>
                            <td><div class="qcell"><span class="qnum">5)</span>Have you started to work out or worked out the details of how to kill yourself? Did you intend to carry out this plan?</div></td>
                            <td class="risk red" aria-label="High Risk">
                                <select id="cssrs_q5" aria-label="Question 5 answer"><option value=""></option><option value="YES">YES</option><option value="NO">NO</option></select>
                            </td>
                        </tr>
                        <tr>
                            <td class="subhdr">Always Ask Question 6</td>
                            <td class="q6right" rowspan="2">
                                <div class="q6grid" aria-label="Question 6 header and responses">
                                    <div class="minihead">Lifetime</div>
                                    <div class="minihead q6rightcol">Past 3 Months</div>
                                    <div class="risk orange q6body" aria-label="Lifetime orange block">
                                        <select id="cssrs_q6" aria-label="Question 6 answer"><option value=""></option><option value="YES">YES</option><option value="NO">NO</option></select>
                                    </div>
                                    <div class="risk red q6body q6rightcol" aria-label="Past 3 Months high risk">
                                        <select id="cssrs_q6_3mo" aria-label="Question 6 within past 3 months answer"><option value=""></option><option value="YES">YES</option><option value="NO">NO</option></select>
                                        <div id="cssrs_q6_3mo_na" class="hidden">N/A</div>
                                    </div>
                                </div>
                            </td>
                        </tr>
                        <tr class="q6row">
                            <td>
                                <div class="q6text"><span class="qnum">6)</span>Have you done anything, started to do anything, or prepared to do anything to end your life?</div>
                                <div class="examples">Examples: Took pills, tried to shoot yourself, cut yourself, tried to hang yourself; or collected pills, obtained a gun, gave away valuables, wrote a will or suicide note, took out pills but didnâ€™t swallow any, held a gun but changed your mind or it was grabbed from your hand, went to the roof but didnâ€™t jump, etc.</div>
                                <div class="follow">If yes, was this within the past 3 months?</div>
                            </td>
                        </tr>
                    </table>
                    <div class="risk-indicator" aria-label="Risk level indicator">
                        <div class="label">Risk level:</div>
                        <div id="cssrs_riskPill" class="risk-pill">Not set</div>
                        <div id="cssrs_riskNote" class="risk-note"></div>
                    </div>
                </div>
                <div class="answers" aria-label="Compiled answers">
                    <h2>Clinical Note (copyable)</h2>
                    <textarea id="cssrs_compiled" readonly>Complete all required fields to generate clinical note.</textarea>
                    <div class="btnrow">
                        <button id="cssrs_copyBtn" type="button">Copy</button>
                        <button id="cssrs_clearBtn" type="button">Clear</button>
                        <span class="status" id="cssrs_status" aria-live="polite"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // --- CSSRS Modal Logic ---
        const ids = ["cssrs_q1","cssrs_q2","cssrs_q3","cssrs_q4","cssrs_q5","cssrs_q6","cssrs_q6_3mo"];
        const el = (id) => document.getElementById(id);
        function valOrBlank(v){ return (v && v.trim()) ? v.trim() : ""; }
        function setDisabled(id, disabled){
            const node = el(id);
            if (!node) return;
            node.disabled = disabled;
            if (disabled) node.value = "";
        }
        function applySkipLogic(){
            const a2 = valOrBlank(el("cssrs_q2").value);
            const skip = (a2 === "NO");
            setDisabled("cssrs_q3", skip);
            setDisabled("cssrs_q4", skip);
            setDisabled("cssrs_q5", skip);
            const a6 = valOrBlank(el("cssrs_q6").value);
            const skip6m = (a6 !== "YES");
            setDisabled("cssrs_q6_3mo", skip6m);
            el("cssrs_q6_3mo").classList.toggle("hidden", skip6m);
            el("cssrs_q6_3mo_na").classList.toggle("hidden", !skip6m);
        }
        function deriveRisk(){
            const a1 = valOrBlank(el("cssrs_q1").value);
            const a2 = valOrBlank(el("cssrs_q2").value);
            const a3 = valOrBlank(el("cssrs_q3").value);
            const a4 = valOrBlank(el("cssrs_q4").value);
            const a5 = valOrBlank(el("cssrs_q5").value);
            const a6 = valOrBlank(el("cssrs_q6").value);
            const a6m = valOrBlank(el("cssrs_q6_3mo").value);
            let high = false, moderate = false, low = false;
            if (a3 === "YES") moderate = true;
            else if (a3 === "NO") low = true;
            if (a4 === "YES" || a5 === "YES"){
                high = true; moderate = false; low = false;
            }
            if (a6 === "YES"){
                if (a6m === "YES"){ high = true; moderate = false; low = false; }
                else if (!high){ moderate = true; low = false; }
            }
            if (!high && !moderate){ low = true; }
            if (high) return { level: "High", cls: "high", note: "Positive intent/plan and/or recent behavior." };
            if (moderate) return { level: "Moderate", cls: "mod", note: "Ideation present without intent/plan or behavior." };
            if (low) return { level: "Low", cls: "low", note: "No intent/plan or behavior endorsed." };
            return { level: "Not set", cls: "", note: "" };
        }
        function updateRiskUI(){
            const risk = deriveRisk();
            const pill = el("cssrs_riskPill");
            const note = el("cssrs_riskNote");
            pill.textContent = risk.level;
            pill.className = "risk-pill" + (risk.cls ? " " + risk.cls : "");
            note.textContent = risk.note;
        }
        function isComplete(){
            const a1 = valOrBlank(el("cssrs_q1").value);
            const a2 = valOrBlank(el("cssrs_q2").value);
            const a3 = valOrBlank(el("cssrs_q3").value);
            const a4 = valOrBlank(el("cssrs_q4").value);
            const a5 = valOrBlank(el("cssrs_q5").value);
            const a6 = valOrBlank(el("cssrs_q6").value);
            const a6m = valOrBlank(el("cssrs_q6_3mo").value);
            if (!a1 || !a2 || !a6) return false;
            if (a2 === "YES" && (!a3 || !a4 || !a5)) return false;
            if (a6 === "YES" && !a6m) return false;
            if (a6 === "NO") return true;
            return true;
        }
        function buildCompiled(){
            if (!isComplete()){
                el("cssrs_compiled").value = "Complete all required fields to generate clinical note.";
                return;
            }
            const a1 = valOrBlank(el("cssrs_q1").value);
            const a2 = valOrBlank(el("cssrs_q2").value);
            const a3 = valOrBlank(el("cssrs_q3").value);
            const a4 = valOrBlank(el("cssrs_q4").value);
            const a5 = valOrBlank(el("cssrs_q5").value);
            const a6 = valOrBlank(el("cssrs_q6").value);
            const a6m = valOrBlank(el("cssrs_q6_3mo").value);
            const risk = deriveRisk();
            const lines = [];
            lines.push("CSSRS (Past Month) - Responses");
            lines.push("1) Have you wished you were dead or wished you could go to sleep and not wake up? Answer: " + (a1 || ""));
            lines.push("2) Have you actually had any thoughts about killing yourself? Answer: " + (a2 || ""));
            if (a2 === "YES"){
                lines.push("3) Have you been thinking about how you might do this? Answer: " + (a3 || ""));
                lines.push("4) Have you had these thoughts and had some intention of acting on them? Answer: " + (a4 || ""));
                lines.push("5) Have you started to work out or worked out the details of how to kill yourself? Did you intend to carry out this plan? Answer: " + (a5 || ""));
            }
            lines.push("6) Have you done anything, started to do anything, or prepared to do anything to end your life? Answer: " + (a6 || ""));
            if (a6 === "YES"){
                lines.push("   If yes, was this within the past 3 months? Answer: " + (a6m || ""));
            } else {
                lines.push("   If yes, was this within the past 3 months? Answer: N/A");
            }
            lines.push("");
            lines.push("Risk level: " + risk.level);
            if (risk.note) lines.push("Risk note: " + risk.note);
            el("cssrs_compiled").value = lines.join("\n");
        }
        async function copyCompiled(){
            const text = el("cssrs_compiled").value;
            if (!text.trim()){
                el("cssrs_status").textContent = "Nothing to copy.";
                return;
            }
            try{
                await navigator.clipboard.writeText(text);
                el("cssrs_status").textContent = "Copied.";
            }catch(e){
                el("cssrs_compiled").focus();
                el("cssrs_compiled").select();
                el("cssrs_status").textContent = "Clipboard blocked. Selected text instead (press Ctrl/Cmd+C).";
            }
        }
        function clearAll(){
            ids.forEach(id => el(id).value = "");
            el("cssrs_status").textContent = "";
            applySkipLogic();
            updateRiskUI();
            buildCompiled();
        }
        ids.forEach(id => {
            const node = el(id);
            if (!node) return;
            node.addEventListener("change", () => {
                applySkipLogic();
                updateRiskUI();
                buildCompiled();
            });
        });
        if (el("cssrs_copyBtn")) el("cssrs_copyBtn").addEventListener("click", copyCompiled);
        if (el("cssrs_clearBtn")) el("cssrs_clearBtn").addEventListener("click", clearAll);
        // Modal open/close logic
        const modal = document.getElementById("cssrsModal");
        const openBtn = document.getElementById("cssrsBtn");
        const closeBtn = document.getElementById("closeCssrsBtn");
        if (openBtn) {
            openBtn.addEventListener("click", ()=>{ modal.classList.remove("hidden"); modal.focus(); });
        } else {
            // If the button is not present at DOMContentLoaded, try again after a short delay (for dynamic UIs)
            setTimeout(() => {
                const retryBtn = document.getElementById("cssrsBtn");
                if (retryBtn) retryBtn.addEventListener("click", ()=>{ modal.classList.remove("hidden"); modal.focus(); });
            }, 1000);
        }
        if (closeBtn) closeBtn.addEventListener("click", ()=>{ modal.classList.add("hidden"); });
        // ESC to close
        document.addEventListener("keydown", (e)=>{
            if (!modal.classList.contains("hidden") && (e.key === "Escape")) modal.classList.add("hidden");
        });
        // Initialize
        applySkipLogic();
        updateRiskUI();
        buildCompiled();

        // Robustly attach CSSRS button event after every render
        function attachCssrsBtnHandler() {
            const modal = document.getElementById("cssrsModal");
            const openBtn = document.getElementById("cssrsBtn");
            if (openBtn && modal) {
                // Remove any previous handler to avoid duplicates
                openBtn.removeEventListener("click", openBtn._cssrsHandler);
                openBtn._cssrsHandler = () => { modal.classList.remove("hidden"); modal.focus(); };
                openBtn.addEventListener("click", openBtn._cssrsHandler);
            }
        }
        // Attach once on DOMContentLoaded
        attachCssrsBtnHandler();
        // Patch the global fullRender (if present) to always re-attach after UI updates
        if (typeof window.fullRender === 'function') {
            const origFullRender = window.fullRender;
            window.fullRender = function(...args) {
                const result = origFullRender.apply(this, args);
                attachCssrsBtnHandler();
                return result;
            };
        }
    });
    </script>

    <div class="container" id="appContainer" style="display: none;">
        <div class="header">
            <h1>Client Data Organizer <span style="font-size: 0.8rem; font-weight: normal; vertical-align: middle;">v1.0.8</span></h1>
            <div id="autoSaveIndicator" class="autosave-indicator" style="opacity: 0;">
                <span id="saveStatus"></span>
            </div>
            <div class="header-menu" id="headerMenu">
                <button id="headerMenuBtn" class="btn header-menu-btn" title="Open menu">Menu â–¾</button>
                <div id="headerMenuDropdown" class="header-menu-dropdown hidden">
                    <button id="informedConsentBtn" class="menu-item-btn">Informed Consent</button>
                    <button id="cssrsBtn" class="menu-item-btn">CSSRS</button>
                    <button id="soapAuditGuideBtn" class="menu-item-btn">SOAP Audit Guide</button>
                    <button id="interventionBankBtn" class="menu-item-btn">Intervention Bank</button>
                    <button id="configureBackupBtn" class="menu-item-btn">Set Secondary Backup Location</button>
                    <button id="clearBackupBtn" class="menu-item-btn">Clear Secondary Backup</button>
                    <button id="manualSaveBtn" class="menu-item-btn save">Save Now</button>
                    <button id="checkForUpdatesBtn" class="menu-item-btn">Check for Updates</button>
                    <button id="settingsBtn" class="menu-item-btn settings">Settings</button>
                    <button id="themeToggleBtn" class="menu-item-btn theme" title="Toggle Theme">Theme</button>
                    <button id="lockScreenBtn" class="menu-item-btn" title="Lock Screen">Lock Screen</button>
                </div>
            </div>
        </div>

        <div class="main-content" id="mainGrid">
            <!-- Clients Panel -->
            <div class="panel clients-panel" id="panelClients">
                <div class="panel-header">
                    <span>Clients</span>
                    <div style="display: flex; align-items: center;">
                        <button id="sortClientsBtn" title="Sort A-Z" class="btn" style="padding: 2px 6px; font-size: 12px; margin-right: 8px;">A-Z</button>
                        <button id="addClientBtn" class="add-btn">+</button>
                    </div>
                </div>
                <div class="panel-content" id="clientList">
                    <div class="no-selection">Click + to add a client</div>
                </div>
                <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Recently Deleted</h3>
                     <div id="deletedClientsList" class="deleted-list"></div>
                     <button id="clearDeletedClientsBtn" class="clear-deleted-btn hidden">Clear All</button>
                </div>
                 <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Archived</h3>
                     <div id="archivedClientsList" class="deleted-list"></div>
                </div>
            </div>

            <div class="resizer" id="resizer1"></div>

            <!-- Appointments Panel -->
            <div class="panel appointments-panel" id="panelAppointments">
                <div class="panel-header">
                    <span>Appointments & Goals</span>
                </div>
                
                <!-- Tab Navigation -->
                <div style="display: flex; border-bottom: 2px solid var(--panel-border); background: var(--panel-bg); flex-shrink: 0;">
                    <button id="appointmentsTabBtn" class="panel-tab-btn active" style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-weight: 600; color: var(--text-color-primary); border-bottom: 3px solid #3498db;">Appointments</button>
                    <button id="goalsTabBtn" class="panel-tab-btn" style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-weight: 600; color: var(--text-color-secondary); border-bottom: 3px solid transparent;">Treatment Goals</button>
                </div>
                
                <!-- Appointments Tab Content -->
                <div id="appointmentsTabContent" class="panel-content" style="display: flex; flex-direction: column;">
                    <div id="appointmentList" style="flex-grow: 1; overflow-y: auto;">
                        <div class="no-selection">Select a client first</div>
                    </div>
                    <div class="panel-footer">
                         <label for="appointmentDateInput" style="font-weight: 600; color: var(--text-color-secondary); font-size: 0.875rem; margin-bottom: 4px; display: block;">Appointment Date</label>
                         <input type="date" id="appointmentDateInput" style="width: 100%; margin-bottom: 8px;">
                         <div style="display: flex; align-items: center; gap: 8px;">
                             <button id="addAppointmentBtn" class="btn save-btn" style="flex: 1; padding: 8px;">+ Add Appointment</button>
                             <button id="updateAppointmentDateBtn" class="btn" style="flex: 1; padding: 8px;">Update Appointment Date</button>
                         </div>
                         <button id="addIntakeBtn" class="btn" style="width: 100%; margin-top: 8px; padding: 8px; background: linear-gradient(135deg, #d35400 0%, #ba4a00 100%);">+ Add Intake Session</button>
                         <div style="margin-top: 12px; border-top: 1px solid var(--panel-border); padding-top: 10px;">
                             <label for="noteNameInput" style="font-weight: 600; color: var(--text-color-secondary); font-size: 0.875rem; margin-bottom: 4px; display: block;">Notes</label>
                             <input type="text" id="noteNameInput" placeholder="Enter note name" style="width: 100%; margin-bottom: 8px; padding: 8px; border: 1px solid var(--input-border); border-radius: 4px; font-size: 14px; font-family: inherit; background-color: var(--input-bg); color: var(--input-text);">
                             <div style="display: flex; align-items: center; gap: 8px;">
                                 <button id="addNoteBtn" class="btn" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #16a085 0%, #138d75 100%);">+ Add Note</button>
                                 <button id="renameNoteBtn" class="btn" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);" disabled>Rename Selected</button>
                             </div>
                         </div>
                    </div>
                     <div class="panel-footer">
                         <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Recently Deleted</h3>
                         <div id="deletedAppointmentsList" class="deleted-list"></div>
                         <button id="clearDeletedAppointmentsBtn" class="clear-deleted-btn hidden">Clear All</button>
                    </div>
                </div>
                
                <!-- Goals Tab Content -->
                <div id="goalsTabContent" class="panel-content" style="display: none; flex-direction: column; overflow-y: auto;">
                    <div style="padding: 10px; border-bottom: 1px solid var(--panel-border); flex-shrink: 0;">
                        <label for="clientDiagnosis" style="font-weight: 600; color: var(--text-color-primary); display: block; margin-bottom: 8px;">Diagnosis</label>
                        <textarea id="clientDiagnosis" placeholder="Enter client diagnoses here for reference..." style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--input-border); border-radius: 4px; font-size: 14px; font-family: inherit; background-color: var(--input-bg); color: var(--input-text); resize: vertical;" disabled></textarea>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--panel-border); flex-shrink: 0;">
                        <span style="font-weight: 600; color: var(--text-color-primary);">Client Goals</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button id="generateGoalsBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem; background: linear-gradient(135deg, #16a085 0%, #138d75 100%);" disabled>Goal/Objective Generator</button>
                            <button id="addGoalBtnInTab" class="add-btn" disabled>+</button>
                        </div>
                    </div>
                    <div id="goalsListInTab" style="flex-grow: 1; overflow-y: auto; padding: 10px;">
                        <div class="no-selection">Select a client to manage goals</div>
                    </div>
                </div>
            </div>

            <div class="resizer" id="resizer2"></div>

            <!-- Session & Notes Panel -->
            <div class="panel session-panel" id="panelSession">
                 <div id="sessionInfoWrapper" class="session-section" style="flex-basis: 50%;">
                     <div class="panel-header">
                         <span>Session Information</span>
                         <button id="customInstructionsBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem; margin-right: 8px;" title="Add custom AI instructions for this note">âš™ï¸ Instructions</button>
                         <button id="generateNoteBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem;" disabled>Generate Note</button>
                     </div>
                     <div class="panel-content">
                         <div id="regularSessionFields">
                         <textarea id="sessionInfo" placeholder="Select an appointment to enter session details..." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                         <div id="auditProofingBlock" class="audit-proofing-block">
                             <div style="font-size: 0.85rem; color: var(--text-color-secondary); font-weight: 700; margin-bottom: 6px;">Audit-Proofing</div>
                             <div class="audit-proofing-grid">
                                 <div class="audit-proofing-field">
                                     <label for="auditProofSymptoms">Symptom Pattern / Severity Context</label>
                                     <textarea id="auditProofSymptoms" placeholder="Add symptom trend, frequency, intensity, and client-reported changes." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                                 <div class="audit-proofing-field">
                                     <label for="auditProofFunctional">Functional Impact</label>
                                     <textarea id="auditProofFunctional" placeholder="Document work/school/relationship/sleep/parenting or daily functioning impact." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                                 <div class="audit-proofing-field">
                                     <label for="auditProofProgress">Progress / Response to Treatment</label>
                                     <textarea id="auditProofProgress" placeholder="Describe measurable progress, barriers, and response to interventions." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                                 <div class="audit-proofing-field">
                                     <label for="auditProofNecessity">Medical Necessity Rationale</label>
                                     <textarea id="auditProofNecessity" placeholder="State why continued skilled treatment is needed at this level of care." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                             </div>
                         </div>
                         </div>
                         <div id="intakeSessionBlock" class="audit-proofing-block hidden">
                             <div style="font-size: 0.85rem; color: var(--text-color-secondary); font-weight: 700; margin-bottom: 6px;">Intake Session Prompts</div>
                             <div id="intakeFieldsContainer" class="audit-proofing-grid"></div>
                         </div>
                     </div>
                     <div class="panel-footer" id="sessionTimerWrapper" style="display: none;">
                         <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                             <button id="startTimerBtn" class="btn" style="flex-grow: 1;">Start</button>
                             <button id="stopTimerBtn" class="btn" style="flex-grow: 1;">Stop</button>
                             <div id="sessionDuration" style="font-weight: 600; white-space: nowrap;">00:00</div>
                         </div>
                     </div>
                 </div>
                 <div class="resizer-y" id="resizer-session-notes"></div>
                 <div id="notesWrapper" class="session-section persistent-notes-section" style="flex-basis: 50%;">
                     <div class="panel-header collapsible-header" data-target="notesContent">
                         <span>Persistent Notes <span class="collapse-icon">â–¼</span></span>
                     </div>
                     <div id="notesContent" class="panel-content collapsible-content">
                         <textarea id="persistentNotes" placeholder="Select a client to enter persistent notes..." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                     </div>
                 </div>
            </div>

            <div class="resizer" id="resizer3"></div>

            <!-- SOAP Notes Panel -->
            <div class="panel soap-panel" id="panelSoap">
                <div class="panel-header">
                    <span>SOAP Note</span>
                </div>
                <div class="panel-content" id="soapContent">
                    <div class="no-selection">Select an appointment to begin</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Custom Instructions Modal -->
    <div id="customInstructionsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Custom AI Instructions</h2>
                <button id="closeCustomInstructionsBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>

            <div style="margin-bottom: 1rem;">
                <label for="persistentInstructionsInput" style="margin-bottom: 0.5rem; font-weight: 600; display: block;">Persistent Instructions</label>
                <textarea id="persistentInstructionsInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 12px; width: 100%; background-color: var(--input-bg); color: var(--input-text); font-family: inherit; font-size: 14px; min-height: 100px; resize: vertical;" placeholder="Applies across all sessions for this client."></textarea>
            </div>

            <div style="margin-bottom: 1rem;">
                <label for="sessionInstructionsInput" style="margin-bottom: 0.5rem; font-weight: 600; display: block;">Session Instructions</label>
                <textarea id="sessionInstructionsInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 12px; width: 100%; background-color: var(--input-bg); color: var(--input-text); font-family: inherit; font-size: 14px; min-height: 110px; resize: vertical;" placeholder="Applies only to the selected appointment/session."></textarea>
                <div style="font-size: 0.8rem; color: var(--text-color-secondary); margin-top: 4px;">
                    If Session Instructions conflict with Persistent Instructions, Session Instructions override for this note.
                </div>
            </div>

            <div style="margin-bottom: 1rem;">
                <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Client Modality Lens (SOAP Default)</label>
                <div style="font-size: 0.82rem; color: var(--text-color-secondary); margin-bottom: 8px;">
                    SOAP generation uses this as the default lens for this client. If session details explicitly indicate different interventions/modalities, those interventions are preserved as written.
                </div>
                <div id="customInstructionsModalitiesList" class="modality-grid"></div>
                <div id="customInstructionsModalityOtherWrap" class="hidden" style="margin-top:8px; max-width: 380px;">
                    <label for="customInstructionsModalityOther" style="font-size:0.9rem; font-weight:600; display:block; margin-bottom:4px;">Other (Specify)</label>
                    <input id="customInstructionsModalityOther" type="text" class="setting-input" placeholder="Optional custom modality..." disabled>
                </div>
            </div>

            <div style="display: flex; gap: 1rem;">
                <button id="saveCustomInstructionsBtn" class="btn save-btn" style="flex-grow: 1;">Save Instructions</button>
                <button id="clearCustomInstructionsBtn" class="btn" style="flex-grow: 1; background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);">Clear Instructions</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Settings</h2>
                <button id="closeSettingsBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Connection</h3>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div>
                        <label for="apiProviderSelect" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">API Provider</label>
                        <select id="apiProviderSelect" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                            <option value="openwebui">Open WebUI</option>
                            <option value="ollama">Ollama (local)</option>
                            <option value="vertex">Google Vertex AI</option>
                            <option value="openai">OpenAI</option>
                        </select>
                    </div>

                    <div id="openwebuiSettings">
                        <div>
                            <label for="serverAddressInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Open WebUI Address</label>
                            <input type="text" id="serverAddressInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="e.g., http://localhost:3000">
                        </div>
                        <div>
                            <label for="apiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">API Key (optional)</label>
                            <input type="password" id="apiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                    </div>

                    <div id="ollamaSettings" class="hidden">
                        <div>
                            <label for="ollamaAddressInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Ollama Address</label>
                            <input type="text" id="ollamaAddressInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="e.g., http://localhost:11434">
                        </div>
                    </div>

                    <div id="vertexSettings" class="hidden">
                        <div>
                            <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Google Cloud Service Account JSON</label>
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 0.5rem;">
                                <button id="selectVertexKeyBtn" class="btn" style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); padding: 6px 12px; font-size: 0.85rem;">Upload JSON Key File</button>
                                <button id="clearVertexKeyBtn" class="btn hidden" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); padding: 6px 12px; font-size: 0.85rem;">Clear</button>
                                <span id="vertexKeyStatus" style="font-size: 0.85rem; color: var(--text-color-secondary);">No file selected</span>
                            </div>
                            <input type="file" id="vertexKeyFileInput" accept=".json" style="display: none;">
                            <textarea id="vertexServiceAccountInput" style="display: none;"></textarea>
                            <small style="color: var(--text-color-secondary); display: block; margin-top: 0.25rem;">Create a Service Account in Google Cloud Console with the "Vertex AI User" role, download the JSON key, and upload it here.</small>
                        </div>
                        <div>
                            <label for="vertexLocationInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Vertex Location</label>
                            <input type="text" id="vertexLocationInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" value="us-central1" placeholder="e.g., us-central1">
                        </div>
                        <div>
                            <label for="vertexModelInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Vertex Model</label>
                            <select id="vertexModelInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                                <option>Connect first</option>
                            </select>
                        </div>
                    </div>
                    
                    <div id="openaiSettings" class="hidden">
                        <div style="background-color: rgba(255, 165, 0, 0.1); border: 1px solid orange; padding: 10px; border-radius: 6px; margin-bottom: 1rem;">
                            <strong style="color: orange;">HIPAA Compliance Notice:</strong>
                            <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">To use OpenAI in a HIPAA-compliant manner, you <strong>must</strong> have a signed Business Associate Agreement (BAA) with OpenAI and ensure you are using their enterprise/API services appropriately. Do not use standard ChatGPT accounts for PHI.</p>
                        </div>
                        <div>
                            <label for="openaiApiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">OpenAI API Key</label>
                            <input type="password" id="openaiApiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                        <div>
                            <label for="openaiModelInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">OpenAI Model</label>
                            <select id="openaiModelInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                                <option>Enter API Key first</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <button id="connectApiBtn" class="btn">Connect</button>
                        <button id="verifyApiBtn" class="btn hidden" title="Test the API connection">Verify</button>
                        <span id="apiStatus" style="font-size: 0.875rem; font-weight: 600;"></span>
                    </div>
                    <div id="modelSelectWrapper">
                         <label for="modelSelect" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">AI Model</label>
                         <select id="modelSelect" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                            <option>Connect to server first</option>
                        </select>
                    </div>
                </div>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Data Management</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 1rem;">
                     <button id="exportBtn" class="btn">Export Data</button>
                     <button id="importBtn" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Import Data</button>
                     <button id="eraseAllBtn" class="btn save-btn">Erase All Data</button>
                </div>
            </div>

            <div style="margin-bottom: 0.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Security</h3>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <input type="password" id="currentPasswordInput" class="setting-input" placeholder="Current password">
                    <input type="password" id="newPasswordInput" class="setting-input" placeholder="New password">
                    <input type="password" id="confirmNewPasswordInput" class="setting-input" placeholder="Confirm new password">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <button id="changePasswordBtn" class="btn">Change Password</button>
                        <span id="changePasswordStatus" style="font-size: 0.875rem; font-weight: 600;"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="goalGeneratorModal" class="modal-overlay hidden">
        <div class="modal-content goal-generator-modal">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Auto-Generate Goals & Objectives</h2>
                <button id="closeGoalGeneratorBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div class="goal-generator-controls">
                <div class="goal-generator-card">
                    <div class="goal-generator-title">Clinical Focus</div>
                    <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;" for="goalProblemInput">Problem / Diagnosis Focus</label>
                    <textarea id="goalProblemInput" class="setting-input" rows="4" placeholder="Describe the presenting problem/diagnosis to target."></textarea>
                </div>
                <div class="goal-generator-card">
                    <div class="goal-generator-title">Generation Settings</div>
                    <div class="goal-generator-secondary">
                    <div>
                        <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;" for="goalCountInput"># Goals</label>
                        <input id="goalCountInput" class="setting-input" type="number" min="1" max="20" value="1">
                    </div>
                    <div>
                        <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;" for="objectiveCountInput"># Objectives per Goal</label>
                        <input id="objectiveCountInput" class="setting-input" type="number" min="1" max="20" value="4">
                    </div>
                    <div>
                        <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;" for="objectiveStyleSelect">Objective Format</label>
                        <select id="objectiveStyleSelect" class="setting-input">
                            <option value="action">Action-Focused</option>
                            <option value="smart">SMART</option>
                        </select>
                    </div>
                    </div>
                </div>
                <div class="goal-generator-card">
                    <div class="goal-generator-title">Modality Lens</div>
                    <div style="font-size: 0.9rem; color: var(--text-color-secondary); font-weight: 600; margin-bottom: 6px;">Choose one or more modalities using + / âˆ’</div>
                    <div id="guidingModalitiesList" class="modality-grid"></div>
                    <div id="guidingModalityOtherWrap" class="hidden" style="margin-top:8px; max-width: 380px;">
                        <label for="guidingModalityOther" style="font-size:0.9rem; font-weight:600; display:block; margin-bottom:4px;">Other (Specify)</label>
                        <input id="guidingModalityOther" type="text" class="setting-input" placeholder="Optional custom modality..." disabled>
                    </div>
                </div>
            </div>
            <div class="goal-generator-actions">
                <button id="runGoalGeneratorBtn" class="btn">Generate Draft</button>
                <button id="applyGeneratedGoalsBtn" class="btn save-btn" disabled>Apply Approved Goals</button>
            </div>
            <div id="generatedGoalsReview" class="intervention-list"></div>
        </div>
    </div>

    <div id="interventionBankModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Intervention Bank</h2>
                <button id="closeInterventionBankBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div style="display:flex;gap:8px;margin-bottom:10px;">
                <input id="newInterventionInput" class="setting-input" type="text" placeholder="Add intervention...">
                <button id="addInterventionBtn" class="btn save-btn" style="width:auto;padding:0 14px;">Add</button>
            </div>
            <div id="interventionBankList" class="intervention-list"></div>
        </div>
    </div>

    <div id="interventionPickerModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Select Interventions for Note</h2>
                <button id="closeInterventionPickerBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div id="interventionPickerList" class="intervention-list" style="margin-bottom:10px;"></div>
            <button id="saveInterventionSelectionBtn" class="btn">Save Selection</button>
        </div>
    </div>

    <div id="addClientModal" class="modal-overlay hidden">
        <div class="modal-content" style="max-width: 420px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.25rem; font-weight: bold;">Add Client</h2>
                <button id="closeAddClientBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                <label for="addClientNameInput" style="font-weight: 600;">Client Name</label>
                <input id="addClientNameInput" type="text" class="setting-input" placeholder="Enter client name">
                <div style="display: flex; gap: 0.75rem; margin-top: 0.25rem;">
                    <button id="confirmAddClientBtn" class="btn save-btn" style="flex: 1;">Add Client</button>
                    <button id="cancelAddClientBtn" class="btn" style="flex: 1; background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <div id="exportDataModal" class="modal-overlay hidden">
        <div class="modal-content" style="max-width: 720px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.25rem; font-weight: bold;">Encrypted SQL Export</h2>
                <button id="closeExportDataBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <p style="margin-bottom: 0.75rem; color: var(--text-color-secondary);">Copy or download this encrypted SQL backup payload to save client data externally.</p>
            <textarea id="exportDataText" class="setting-input" style="width:100%; min-height: 260px; font-family: monospace;" readonly></textarea>
            <div style="display: flex; gap: 0.75rem; margin-top: 0.9rem;">
                <button id="copyExportDataBtn" class="btn" style="flex:1;">Copy Encrypted SQL</button>
                <button id="downloadExportDataBtn" class="btn save-btn" style="flex:1;">Download Encrypted SQL</button>
            </div>
        </div>
    </div>

    <div id="informedConsentModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Informed Consent</h2>
                <button id="closeConsentBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div style="max-height: 60vh; overflow-y: auto; margin-bottom: 1.5rem; line-height: 1.6;">
                <p>What we discuss here is confidential, with legal limits. I may need to break confidentiality if there is a risk of serious harm to you or others, suspected abuse of a child, elderly, or vulnerable adult, or if records are legally required. Sessions are billed at the agreed fee, and insurance is billed when applicable. You are responsible for any copays, deductibles, or denied claims. Appointments cancelled with less than 24 hours' notice, or missed entirely, are charged the full session fee. I wait up to ten minutes for scheduled sessions before a session is considered missed. Email is used for scheduling and administrative communication only, not emergencies. If you are in crisis, please contact 988 or call 911. Do you have any questions before we continue?</p>
            </div>
            <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button id="closeConsentBtnBottom" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Close</button>
            </div>
        </div>
    </div>

    <div id="soapAuditGuideModal" class="modal-overlay hidden">
        <div class="modal-content guide-modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Audit-Ready SOAP Documentation Guide</h2>
                <button id="closeSoapAuditGuideBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>

            <div class="guide-scroll">
                <p style="margin-bottom: 0.6rem;">Comprehensive, audit-ready guidance for writing mental health SOAP notes that reduce risk of clawbacks, recoupments, and audit findings. Structured for outpatient behavioral health, with principles that apply broadly.</p>

                <h3>Core Principles That Protect Against Clawbacks</h3>
                <p>Audits typically look for:</p>
                <ul>
                    <li>Medical necessity</li>
                    <li>Clear link between symptoms and treatment</li>
                    <li>Measurable progress or clinical rationale</li>
                    <li>Appropriate level of care</li>
                    <li>Time documentation that matches billing</li>
                    <li>Consistency between diagnosis, treatment plan, and note</li>
                    <li>Compliance with payer requirements</li>
                    <li>No cloning or copy-paste patterns</li>
                    <li>Legible, specific documentation</li>
                    <li>Support for continued treatment</li>
                </ul>

                <div class="guide-callout">
                    <strong>Central question every note must answer:</strong><br>
                    Why was this service medically necessary today?
                </div>

                <h3>Required Elements in Every SOAP Note</h3>

                <h4>S â€“ Subjective</h4>
                <p>This section documents:</p>
                <ul>
                    <li>Clientâ€™s report of symptoms</li>
                    <li>Functional impact</li>
                    <li>Relevant changes since last session</li>
                    <li>Medication changes</li>
                    <li>Safety concerns</li>
                    <li>Clientâ€™s perspective on progress</li>
                </ul>
                <p>Must include:</p>
                <ul>
                    <li>Symptom description</li>
                    <li>Duration or frequency when relevant</li>
                    <li>Severity when relevant</li>
                    <li>Functional impairment</li>
                    <li>Direct quotes when helpful</li>
                </ul>
                <div class="guide-example">
                    <strong>Example (Strong)</strong><br>
                    Client reports increased anxiety over the past week, describing daily panic symptoms lasting 20â€“30 minutes. Sleep has decreased to 4â€“5 hours per night. Client states, â€œI am avoiding meetings because I feel like I will lose control.â€ Reports decreased work performance and difficulty concentrating.
                </div>
                <div class="guide-example">
                    <strong>Example (Weak)</strong><br>
                    Client reports feeling anxious.<br>
                    <strong>Why weak:</strong> lacks severity, duration, and functional impact.
                </div>

                <h4>O â€“ Objective</h4>
                <p>This section documents observable data. Includes:</p>
                <ul>
                    <li>Appearance</li>
                    <li>Behavior</li>
                    <li>Mood and affect (clinician observed)</li>
                    <li>Orientation</li>
                    <li>Speech</li>
                    <li>Thought process</li>
                    <li>Risk assessment findings</li>
                    <li>Engagement level</li>
                </ul>
                <p>Must include:</p>
                <ul>
                    <li>Mental status indicators</li>
                    <li>Safety assessment when clinically indicated</li>
                    <li>Any measurable data used (scales, scores)</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Client appeared fatigued with constricted affect. Speech was coherent and goal-directed. No psychosis observed. Oriented x4. Denies suicidal ideation, plan, or intent. Engaged throughout session.
                </div>
                <div class="guide-example">
                    <strong>Standardized measure example</strong><br>
                    GAD-7 score increased from 11 to 16 since last assessment.
                </div>

                <h4>A â€“ Assessment</h4>
                <p>This is the most important section for audits. It must demonstrate:</p>
                <ul>
                    <li>Clinical interpretation</li>
                    <li>Progress toward goals</li>
                    <li>Ongoing medical necessity</li>
                    <li>Response to treatment</li>
                    <li>Risk level</li>
                    <li>Diagnostic justification if relevant</li>
                </ul>
                <p>Must include:</p>
                <ul>
                    <li>Progress or lack of progress</li>
                    <li>Why continued treatment is needed</li>
                    <li>Connection to diagnosis</li>
                    <li>Clinical reasoning</li>
                </ul>
                <div class="guide-example">
                    <strong>Strong Example</strong><br>
                    Symptoms remain consistent with Generalized Anxiety Disorder, currently moderate to severe. Increased avoidance behaviors are interfering with occupational functioning. Client has demonstrated partial progress in cognitive restructuring skills but continues to require structured intervention to reduce functional impairment. Continued weekly therapy is medically necessary to prevent further deterioration.
                </div>
                <div class="guide-example">
                    <strong>Weak Example</strong><br>
                    Client is doing okay. Continue treatment.<br>
                    <strong>Why weak:</strong> no medical necessity, no progress detail.
                </div>

                <h4>P â€“ Plan</h4>
                <p>Must include:</p>
                <ul>
                    <li>Interventions used in session</li>
                    <li>Response to interventions</li>
                    <li>Homework or between-session tasks</li>
                    <li>Next session plan</li>
                    <li>Referrals if applicable</li>
                    <li>Risk follow-up if needed</li>
                    <li>Coordination of care if done</li>
                </ul>
                <p><strong>Must Align With Treatment Plan:</strong> Each session should clearly relate to at least one active treatment goal.</p>
                <div class="guide-example">
                    <strong>Strong Example</strong><br>
                    Continued CBT targeting cognitive distortions related to workplace anxiety. Client practiced thought record exercise in session. Assigned daily tracking of avoidance behaviors. Will continue weekly sessions. Next session to focus on exposure hierarchy development.
                </div>

                <h3>Medical Necessity Requirements</h3>
                <p>To withstand audits, notes should demonstrate:</p>
                <ul>
                    <li>Active symptoms</li>
                    <li>Functional impairment</li>
                    <li>Treatment addressing diagnosis</li>
                    <li>Skilled intervention required</li>
                    <li>Not appropriate for self-help or lower level of care</li>
                </ul>

                <h4>Include Functional Impact</h4>
                <p>Auditors often deny claims when notes lack impairment. Examples of functional impairment:</p>
                <ul>
                    <li>Work interference</li>
                    <li>Relationship strain</li>
                    <li>Sleep disruption</li>
                    <li>Academic difficulty</li>
                    <li>Parenting impairment</li>
                    <li>Avoidance behavior</li>
                    <li>Emotional dysregulation</li>
                    <li>Safety concerns</li>
                </ul>

                <h3>Time Documentation</h3>
                <ul>
                    <li>If billing time-based codes, document start and end time OR total time.</li>
                    <li>Match documentation to billing code requirements.</li>
                    <li>Include psychotherapy time separate from other services when applicable.</li>
                    <li>Avoid rounding inconsistently.</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    53-minute psychotherapy session conducted from 10:02 AM to 10:55 AM.
                </div>

                <h3>Risk Assessment Documentation</h3>
                <p>Document when clinically appropriate:</p>
                <ul>
                    <li>Suicidal ideation</li>
                    <li>Homicidal ideation</li>
                    <li>Self-harm risk</li>
                    <li>Protective factors</li>
                    <li>Level of risk</li>
                    <li>Safety plan if needed</li>
                </ul>
                <p>Even if negative, document it.</p>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Client denies suicidal or homicidal ideation. No self-harm behaviors reported. Protective factors include supportive spouse and children. Risk assessed as low.
                </div>

                <h3>Link to Treatment Plan</h3>
                <p>Every session should:</p>
                <ul>
                    <li>Reference at least one goal</li>
                    <li>Show progress toward measurable objectives</li>
                    <li>Document interventions tied to goals</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Treatment Plan Goal: Reduce panic attacks from 4 per week to 1 per week within 8 weeks.<br>
                    SOAP Note Assessment: Client reports decrease from 4 to 2 panic episodes weekly, indicating measurable progress toward treatment goal.
                </div>
                <p>Auditors look for this alignment.</p>

                <h3>Common Audit Red Flags</h3>
                <p>Avoid:</p>
                <ul>
                    <li>Copy and paste notes</li>
                    <li>Identical wording across sessions</li>
                    <li>Vague descriptions</li>
                    <li>Missing diagnosis in note</li>
                    <li>No evidence of progress</li>
                    <li>No functional impairment</li>
                    <li>No intervention described</li>
                    <li>Inconsistent time documentation</li>
                    <li>Overly brief notes for high-level billing</li>
                    <li>Using psychotherapy codes without documenting therapy techniques</li>
                    <li>Billing family sessions without documenting client involvement</li>
                </ul>

                <h3>Special Considerations</h3>
                <h4>Telehealth</h4>
                <p>Document:</p>
                <ul>
                    <li>Platform used</li>
                    <li>Client location</li>
                    <li>Consent</li>
                    <li>Privacy confirmation</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Session conducted via secure telehealth platform. Client confirmed private location in home.
                </div>

                <h4>Medication Coordination</h4>
                <p>If applicable:</p>
                <ul>
                    <li>Document collaboration</li>
                    <li>Note ROI if needed</li>
                    <li>Record communication summary</li>
                </ul>

                <h4>Crisis Sessions</h4>
                <p>Must document:</p>
                <ul>
                    <li>Risk assessment</li>
                    <li>Safety planning</li>
                    <li>Increased level of care reasoning</li>
                    <li>Time spent</li>
                    <li>Follow-up plan</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Include risk assessment findings, safety planning steps taken, rationale for level of care, duration of crisis work, and explicit follow-up actions.
                </div>

                <h3>Example of a Fully Auditable SOAP Note</h3>
                <div class="guide-example">
                    <strong>S:</strong><br>
                    Client reports ongoing workplace anxiety with increased avoidance of meetings. States panic symptoms occur 3 times per week lasting approximately 20 minutes. Reports sleep disruption and difficulty concentrating. Describes fear of negative evaluation.
                </div>
                <div class="guide-example">
                    <strong>O:</strong><br>
                    Client appeared tense with anxious affect. Speech clear and organized. Oriented x4. No psychotic symptoms observed. Denies suicidal or homicidal ideation. Engaged throughout session.
                </div>
                <div class="guide-example">
                    <strong>A:</strong><br>
                    Symptoms consistent with Generalized Anxiety Disorder. Functional impairment present in occupational setting. Partial progress noted in cognitive restructuring skills. Continued weekly psychotherapy is medically necessary to reduce symptom severity and restore work functioning.
                </div>
                <div class="guide-example">
                    <strong>P:</strong><br>
                    Provided CBT focused on cognitive distortions. Practiced thought record in session. Assigned daily tracking of avoidance behaviors. Continue weekly sessions. Reassess symptom scale in two weeks.
                </div>

                <h3>Documentation Checklist for Every Note</h3>
                <p>Before signing, confirm:</p>
                <ul class="guide-checklist">
                    <li>â˜ Diagnosis supported</li>
                    <li>â˜ Symptoms described with detail</li>
                    <li>â˜ Functional impairment documented</li>
                    <li>â˜ Intervention clearly stated</li>
                    <li>â˜ Client response recorded</li>
                    <li>â˜ Medical necessity explained</li>
                    <li>â˜ Progress toward goals documented</li>
                    <li>â˜ Risk assessed when appropriate</li>
                    <li>â˜ Time documented accurately</li>
                    <li>â˜ Note is individualized</li>
                    <li>â˜ No copy-paste language</li>
                    <li>â˜ Plan aligns with treatment plan</li>
                </ul>

                <h3>Best Practices to Reduce Audit Risk</h3>
                <ul>
                    <li>Write notes immediately after session.</li>
                    <li>Tie every session to a treatment goal.</li>
                    <li>Use measurable language.</li>
                    <li>Document change over time.</li>
                    <li>Avoid excessive brevity.</li>
                    <li>Avoid unnecessary narrative.</li>
                    <li>Keep diagnosis consistent with treatment focus.</li>
                    <li>Update treatment plan regularly.</li>
                    <li>Use standardized measures periodically.</li>
                    <li>Ensure billing code matches documentation depth.</li>
                </ul>
            </div>

            <div style="display: flex; justify-content: flex-end; margin-top: 0.9rem;">
                <button id="closeSoapAuditGuideBtnBottom" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Close</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" class="hidden" accept="application/json,.json,.sql,text/plain">

    <script type="module">
        import { fetch as tauriFetch } from '@tauri-apps/plugin-http';
        import { save, ask, message } from '@tauri-apps/plugin-dialog';
        import { writeTextFile } from '@tauri-apps/plugin-fs';
        import { check } from '@tauri-apps/plugin-updater';
        import { relaunch } from '@tauri-apps/plugin-process';
        import { checkFirstLogin, createUser, loginUser, getLastAuthError, changePassword, requestPasswordReset, confirmPasswordReset, requestEmailVerification, confirmEmailVerification, updateRecoverySettings, getRecoverySettings, testSmtpSettings, deleteUserAccount, saveState, loadState, isDatabaseInitialized, importEncryptedSqlDump, importSqlDump, exportEncryptedSqlDump } from './src/database.js';

        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const clientListEl = document.getElementById('clientList');
            const addClientBtn = document.getElementById('addClientBtn');
            const sortClientsBtn = document.getElementById('sortClientsBtn');
            const appointmentListEl = document.getElementById('appointmentList');
            const addAppointmentBtn = document.getElementById('addAppointmentBtn');
            const addIntakeBtn = document.getElementById('addIntakeBtn');
            const appointmentDateInput = document.getElementById('appointmentDateInput');
            const updateAppointmentDateBtn = document.getElementById('updateAppointmentDateBtn');
            const noteNameInput = document.getElementById('noteNameInput');
            const addNoteBtn = document.getElementById('addNoteBtn');
            const renameNoteBtn = document.getElementById('renameNoteBtn');
            const deletedClientsListEl = document.getElementById('deletedClientsList');
            const clearDeletedClientsBtn = document.getElementById('clearDeletedClientsBtn');
            const archivedClientsListEl = document.getElementById('archivedClientsList');
            const deletedAppointmentsListEl = document.getElementById('deletedAppointmentsList');
            const clearDeletedAppointmentsBtn = document.getElementById('clearDeletedAppointmentsBtn');
            const persistentNotesEl = document.getElementById('persistentNotes');
            const clientDiagnosisEl = document.getElementById('clientDiagnosis');
            const sessionInfoEl = document.getElementById('sessionInfo');
            const auditProofSymptomsEl = document.getElementById('auditProofSymptoms');
            const auditProofFunctionalEl = document.getElementById('auditProofFunctional');
            const auditProofProgressEl = document.getElementById('auditProofProgress');
            const auditProofNecessityEl = document.getElementById('auditProofNecessity');
            const regularSessionFieldsEl = document.getElementById('regularSessionFields');
            const auditProofingBlockEl = document.getElementById('auditProofingBlock');
            const intakeSessionBlockEl = document.getElementById('intakeSessionBlock');
            const intakeFieldsContainerEl = document.getElementById('intakeFieldsContainer');
            const guidingModalitiesListEl = document.getElementById('guidingModalitiesList');
            const guidingModalityOtherWrapEl = document.getElementById('guidingModalityOtherWrap');
            const guidingModalityOtherEl = document.getElementById('guidingModalityOther');
            const soapContentEl = document.getElementById('soapContent');
            const autoSaveIndicator = document.getElementById('autoSaveIndicator');
            const saveStatus = document.getElementById('saveStatus');
            // Session Timer Elements
            const sessionTimerWrapper = document.getElementById('sessionTimerWrapper');
            const startTimerBtn = document.getElementById('startTimerBtn');
            const stopTimerBtn = document.getElementById('stopTimerBtn');
            const sessionDurationEl = document.getElementById('sessionDuration');
            // Settings and Modal Elements
            const settingsBtn = document.getElementById('settingsBtn');
            const checkForUpdatesBtn = document.getElementById('checkForUpdatesBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsBtn = document.getElementById('closeSettingsBtn');
            const informedConsentBtn = document.getElementById('informedConsentBtn');
            const cssrsBtn = document.getElementById('cssrsBtn');
            const soapAuditGuideBtn = document.getElementById('soapAuditGuideBtn');
            const interventionBankBtn = document.getElementById('interventionBankBtn');
            const informedConsentModal = document.getElementById('informedConsentModal');
            const closeConsentBtn = document.getElementById('closeConsentBtn');
            const closeConsentBtnBottom = document.getElementById('closeConsentBtnBottom');
            const soapAuditGuideModal = document.getElementById('soapAuditGuideModal');
            const closeSoapAuditGuideBtn = document.getElementById('closeSoapAuditGuideBtn');
            const closeSoapAuditGuideBtnBottom = document.getElementById('closeSoapAuditGuideBtnBottom');
            const goalGeneratorModal = document.getElementById('goalGeneratorModal');
            const closeGoalGeneratorBtn = document.getElementById('closeGoalGeneratorBtn');
            const generateGoalsBtn = document.getElementById('generateGoalsBtn');
            const addClientModal = document.getElementById('addClientModal');
            const closeAddClientBtn = document.getElementById('closeAddClientBtn');
            const cancelAddClientBtn = document.getElementById('cancelAddClientBtn');
            const confirmAddClientBtn = document.getElementById('confirmAddClientBtn');
            const addClientNameInput = document.getElementById('addClientNameInput');
            const exportDataModal = document.getElementById('exportDataModal');
            const closeExportDataBtn = document.getElementById('closeExportDataBtn');
            const exportDataText = document.getElementById('exportDataText');
            const copyExportDataBtn = document.getElementById('copyExportDataBtn');
            const downloadExportDataBtn = document.getElementById('downloadExportDataBtn');
            const goalProblemInput = document.getElementById('goalProblemInput');
            const goalCountInput = document.getElementById('goalCountInput');
            const objectiveCountInput = document.getElementById('objectiveCountInput');
            const objectiveStyleSelect = document.getElementById('objectiveStyleSelect');
            const runGoalGeneratorBtn = document.getElementById('runGoalGeneratorBtn');
            const applyGeneratedGoalsBtn = document.getElementById('applyGeneratedGoalsBtn');
            const generatedGoalsReview = document.getElementById('generatedGoalsReview');
            const interventionBankModal = document.getElementById('interventionBankModal');
            const closeInterventionBankBtn = document.getElementById('closeInterventionBankBtn');
            const newInterventionInput = document.getElementById('newInterventionInput');
            const addInterventionBtn = document.getElementById('addInterventionBtn');
            const interventionBankList = document.getElementById('interventionBankList');
            const interventionPickerModal = document.getElementById('interventionPickerModal');
            const closeInterventionPickerBtn = document.getElementById('closeInterventionPickerBtn');
            const interventionPickerList = document.getElementById('interventionPickerList');
            const saveInterventionSelectionBtn = document.getElementById('saveInterventionSelectionBtn');
            const manualSaveBtn = document.getElementById('manualSaveBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const eraseAllBtn = document.getElementById('eraseAllBtn');
            const currentPasswordInput = document.getElementById('currentPasswordInput');
            const newPasswordInput = document.getElementById('newPasswordInput');
            const confirmNewPasswordInput = document.getElementById('confirmNewPasswordInput');
            const changePasswordBtn = document.getElementById('changePasswordBtn');
            const changePasswordStatus = document.getElementById('changePasswordStatus');
            // Custom Instructions Modal Elements
            const customInstructionsBtn = document.getElementById('customInstructionsBtn');
            const customInstructionsModal = document.getElementById('customInstructionsModal');
            const closeCustomInstructionsBtn = document.getElementById('closeCustomInstructionsBtn');
            const persistentInstructionsInput = document.getElementById('persistentInstructionsInput');
            const sessionInstructionsInput = document.getElementById('sessionInstructionsInput');
            const saveCustomInstructionsBtn = document.getElementById('saveCustomInstructionsBtn');
            const clearCustomInstructionsBtn = document.getElementById('clearCustomInstructionsBtn');
            const customInstructionsModalitiesListEl = document.getElementById('customInstructionsModalitiesList');
            const customInstructionsModalityOtherWrapEl = document.getElementById('customInstructionsModalityOtherWrap');
            const customInstructionsModalityOtherEl = document.getElementById('customInstructionsModalityOther');
            // AI Integration Elements
            const apiProviderSelect = document.getElementById('apiProviderSelect');
            const openwebuiSettings = document.getElementById('openwebuiSettings');
            const serverAddressInput = document.getElementById('serverAddressInput');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const ollamaSettings = document.getElementById('ollamaSettings');
            const ollamaAddressInput = document.getElementById('ollamaAddressInput');
            const vertexSettings = document.getElementById('vertexSettings');
            const vertexServiceAccountInput = document.getElementById('vertexServiceAccountInput');
            const selectVertexKeyBtn = document.getElementById('selectVertexKeyBtn');
            const clearVertexKeyBtn = document.getElementById('clearVertexKeyBtn');
            const vertexKeyFileInput = document.getElementById('vertexKeyFileInput');
            const vertexKeyStatus = document.getElementById('vertexKeyStatus');
            const vertexLocationInput = document.getElementById('vertexLocationInput');
            const vertexModelInput = document.getElementById('vertexModelInput');
            const openaiSettings = document.getElementById('openaiSettings');
            const openaiApiKeyInput = document.getElementById('openaiApiKeyInput');
            const openaiModelInput = document.getElementById('openaiModelInput');
            const connectApiBtn = document.getElementById('connectApiBtn');
            const verifyApiBtn = document.getElementById('verifyApiBtn');
            const apiStatus = document.getElementById('apiStatus');
            const modelSelect = document.getElementById('modelSelect');
            const modelSelectWrapper = document.getElementById('modelSelectWrapper');
            const generateNoteBtn = document.getElementById('generateNoteBtn');
            const fileInput = document.getElementById('fileInput');
            const headerMenu = document.getElementById('headerMenu');
            const headerMenuBtn = document.getElementById('headerMenuBtn');
            const headerMenuDropdown = document.getElementById('headerMenuDropdown');
            const configureBackupBtn = document.getElementById('configureBackupBtn');
            const clearBackupBtn = document.getElementById('clearBackupBtn');
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            const lockScreenBtn = document.getElementById('lockScreenBtn');
            // Goals Elements
            const goalsListInTabEl = document.getElementById('goalsListInTab');
            const addGoalBtnInTab = document.getElementById('addGoalBtnInTab');
            const appointmentsTabBtn = document.getElementById('appointmentsTabBtn');
            const goalsTabBtn = document.getElementById('goalsTabBtn');
            const appointmentsTabContent = document.getElementById('appointmentsTabContent');
            const goalsTabContent = document.getElementById('goalsTabContent');

            // App State
            let data = { clients: [], archivedClients: [] };
            let deletedItems = { clients: [], appointments: [], notes: [] };
            let selectedClientId = null;
            let selectedAppointmentId = null;
            let selectedNoteId = null;
            let selectedIntakeId = null;
            let isDirty = false;
            let apiProvider = 'openwebui';
            let serverAddress = null;
            let apiKey = null;
            let ollamaAddress = null;
            let vertexServiceAccount = null;
            let vertexLocation = 'us-central1';
            let openaiApiKey = null;
            let selectedModel = null;
            let sessionTimerInterval = null;
            let persistentInstructions = '';
            let sessionInstructions = '';
            let generatedGoalsDraft = [];
            let goalGeneratorModalities = [];
            let goalGeneratorModalityOther = '';
            let autoBackupPath = '';
            let backupWriteInProgress = false;
            let backupWritePending = false;
            const getGoogleAccessToken = async (serviceAccountJson) => {
                try {
                    const { invoke } = window.__TAURI__.core;
                    const token = await invoke('generate_google_token', { serviceAccountJson });
                    if (!token) {
                        throw new Error("Rust backend returned an empty token.");
                    }
                    return token;
                } catch (error) {
                    console.error('Error invoking Rust backend for Google Access Token:', error);
                    const errorMessage = typeof error === 'string' ? error : (error.message || JSON.stringify(error));
                    throw new Error(`Failed to generate token via Rust backend: ${errorMessage}`);
                }
            };
            const DEFAULT_INTERVENTION_BANK = [
                'Acceptance', 'Career Counseling', 'CBT: Behavioral Activation', 'CBT: Cognitive Challenging', 'CBT: Cognitive Reframing',
                'CBT: Cognitive Restructuring', 'CBT: Identifying/Challenging Cognitive Distortions', 'CBT: Mindfulness Training',
                'Collaborative Problem-Solving', 'Collaborative Treatment Planning', 'Communication Skills Training',
                'Conflict Resolution Skill Development', 'Decisional Balance', 'Diagnostic Assessment', 'DPerspective Taking',
                'EFCT â€“ Choreographing Enactments', 'EFCT â€“ De-Escalation', 'EFCT â€“ Empathetic Conjecture', 'EFCT â€“ Evocative Responding',
                'EFCT â€“ Facilitation of Emotional Engagement', 'EFCT â€“ Heightening', 'EFCT â€“ Reflection', 'EFCT â€“ Restructuring Interactions',
                'Emotional Processing', 'Exploration of Coping Patterns', 'Exploration of Core Beliefs', 'Exploration of Family Dynamics',
                'Exploration of Relationship Patterns', 'Family Consultation', 'Grief Counseling', 'Inner Child Work',
                'MI: Decisional Balance (pros/cons)', 'MI: Developing Discrepancy', 'MI: Developing Motivation', 'MI: Eliciting Change Talk',
                'MI: Evoking Commitment Language', 'NT: Deconstruction', 'NT: Externalization', 'NT: Identifying Meaning-Making Patterns',
                'NT: Re-Authoring', 'NT: Re-Framing', 'NT: Re-membering', 'NT: Scaffolding Questions', 'NT: Use of Metaphor/Imagery',
                'NT: Values Exploration', 'PD: Confrontation', 'PD: Exploration of Attachment Patterns', 'PD: Exploration of Themes and Patterns',
                'PD: Exploration of Transference', 'PD: Explore Defense Mechanisms', 'PD: Insight & Emotional Integration', 'PD: Interpretation', 'PD: Reflection'
            ];
            const getInitialData = () => ({ clients: [], archivedClients: [], interventionBank: [...DEFAULT_INTERVENTION_BANK] });
            const intakePromptFields = [
                { key: 'presentingProblem', label: 'Presenting Problem' },
                { key: 'riskAssessment', label: 'Risk Assessment' },
                { key: 'objectiveContent', label: 'Objective Content' },
                { key: 'identification', label: 'Identification' },
                { key: 'historyPresentingProblem', label: 'History of Presenting Problem' },
                { key: 'psychiatricHistory', label: 'Psychiatric History' },
                { key: 'traumaHistory', label: 'Trauma History' },
                { key: 'familyPsychHistory', label: 'Family Psychiatric History' },
                { key: 'medicalConditionsHistory', label: 'Medical Conditions and History' },
                { key: 'currentMedications', label: 'Current Medications' },
                { key: 'substanceUse', label: 'Substance Use' },
                { key: 'familyHistory', label: 'Family History' },
                { key: 'socialHistory', label: 'Social History' },
                { key: 'spiritualCulturalFactors', label: 'Spiritual/Cultural Factors' },
                { key: 'developmentalHistory', label: 'Developmental History' },
                { key: 'educationalVocationalHistory', label: 'Educational/Vocational History' },
                { key: 'legalHistory', label: 'Legal History' },
                { key: 'snap', label: 'SNAP' },
                { key: 'otherImportantInformation', label: 'Other Important Information' },
                { key: 'plan', label: 'Plan' },
                { key: 'diagnosis', label: 'Diagnosis' }
            ];
            const DEFAULT_GUIDING_MODALITIES = ['Psychodynamic Psychotherapy', 'Narrative Therapy'];
            const GUIDING_MODALITY_OPTIONS = [
                'CBT (Cognitive Behavioral Therapy)',
                'DBT (Dialectical Behavior Therapy)',
                'ACT (Acceptance and Commitment Therapy)',
                'REBT (Rational Emotive Behavior Therapy)',
                'CPT (Cognitive Processing Therapy)',
                'ERP (Exposure and Response Prevention)',
                'Behavioral Activation (BA)',
                'TF-CBT (Trauma-Focused CBT)',
                'Psychodynamic Psychotherapy',
                'Psychoanalysis',
                'IFS (Internal Family Systems)',
                'Object Relations Therapy',
                'Attachment-Based Therapy',
                'EFT (Emotionally Focused Therapy)',
                'Person-Centered Therapy',
                'Gestalt Therapy',
                'Existential Therapy',
                'Narrative Therapy',
                'Solution-Focused Brief Therapy (SFBT)',
                'Logotherapy',
                'Other (Specify)'
            ];
            goalGeneratorModalities = [...DEFAULT_GUIDING_MODALITIES];

            // --- Data Management ---
            const findClient = id => data.clients.find(c => c.id === id) || data.archivedClients.find(c => c.id === id);
            const findAppointment = (client, id) => client?.appointments.find(a => a.id === id);
            const findNote = (client, id) => client?.notes?.find(n => n.id === id);
            const findIntakeSession = (client, id) => client?.intakeSessions?.find(i => i.id === id);

            const normalizeClientData = () => {
                const allClients = [...(data.clients || []), ...(data.archivedClients || [])];
                allClients.forEach(client => {
                    if (!Array.isArray(client.appointments)) client.appointments = [];
                    if (!Array.isArray(client.notes)) client.notes = [];
                    if (!Array.isArray(client.intakeSessions)) client.intakeSessions = [];
                    if (!Array.isArray(client.goals)) client.goals = [];
                    if (typeof client.persistentInstructions !== 'string') client.persistentInstructions = '';
                    client.goals.forEach(goal => {
                        if (!goal.timelineMonths) goal.timelineMonths = 12;
                        if (!Array.isArray(goal.objectives)) goal.objectives = [];
                        goal.objectives.forEach(obj => {
                            if (!obj.timelineMonths) obj.timelineMonths = 3;
                            if (!obj.format) obj.format = 'action';
                        });
                    });
                    client.appointments.forEach(appt => {
                        if (!Array.isArray(appt.selectedInterventions)) appt.selectedInterventions = [];
                        if (typeof appt.sessionInstructions !== 'string') {
                            appt.sessionInstructions = typeof appt.customInstructions === 'string' ? appt.customInstructions : '';
                        }
                        if (appt.customInstructions !== undefined) {
                            delete appt.customInstructions;
                        }
                    });

                    if (!client.goalGenerationLens || typeof client.goalGenerationLens !== 'object') {
                        client.goalGenerationLens = {
                            modalities: [...DEFAULT_GUIDING_MODALITIES],
                            other: ''
                        };
                    }
                    if (!Array.isArray(client.goalGenerationLens.modalities) || client.goalGenerationLens.modalities.length === 0) {
                        client.goalGenerationLens.modalities = [...DEFAULT_GUIDING_MODALITIES];
                    }
                    if (typeof client.goalGenerationLens.other !== 'string') {
                        client.goalGenerationLens.other = '';
                    }
                });

                if (!Array.isArray(data.interventionBank) || data.interventionBank.length === 0) {
                    data.interventionBank = [...DEFAULT_INTERVENTION_BANK];
                }

                if (!deletedItems || typeof deletedItems !== 'object') {
                    deletedItems = { clients: [], appointments: [], notes: [] };
                }
                if (!Array.isArray(deletedItems.clients)) deletedItems.clients = [];
                if (!Array.isArray(deletedItems.appointments)) deletedItems.appointments = [];
                if (!Array.isArray(deletedItems.notes)) deletedItems.notes = [];
            };

            const containsAny = (text, patterns) => patterns.some(pattern => pattern.test(text));

            const getAuditProofingData = (appointment) => {
                if (!appointment) {
                    return {
                        symptoms: '',
                        functionalImpact: '',
                        progressResponse: '',
                        medicalNecessity: ''
                    };
                }

                const raw = appointment.auditProofing;
                if (!raw) {
                    return {
                        symptoms: '',
                        functionalImpact: '',
                        progressResponse: '',
                        medicalNecessity: ''
                    };
                }

                if (typeof raw === 'string') {
                    return {
                        symptoms: '',
                        functionalImpact: '',
                        progressResponse: raw,
                        medicalNecessity: ''
                    };
                }

                return {
                    symptoms: raw.symptoms || '',
                    functionalImpact: raw.functionalImpact || '',
                    progressResponse: raw.progressResponse || '',
                    medicalNecessity: raw.medicalNecessity || ''
                };
            };

            const saveAuditProofingField = (fieldKey, value) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!appointment) return;

                const current = getAuditProofingData(appointment);
                current[fieldKey] = value;
                appointment.auditProofing = current;
                delete appointment.auditCheck;
                markDirty();
                generateNoteBtn.disabled = !hasAppointmentGenerationInput(appointment);
            };

            const renderIntakeFields = (intakeSession) => {
                if (!intakeFieldsContainerEl) return;

                intakeFieldsContainerEl.innerHTML = '';
                if (!intakeSession) return;

                if (!intakeSession.fields || typeof intakeSession.fields !== 'object') {
                    intakeSession.fields = {};
                }

                intakePromptFields.forEach(field => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'audit-proofing-field';

                    const label = document.createElement('label');
                    label.setAttribute('for', `intake-${field.key}`);
                    label.textContent = field.label;

                    const textarea = document.createElement('textarea');
                    textarea.id = `intake-${field.key}`;
                    textarea.className = 'intake-field-input';
                    textarea.dataset.intakeKey = field.key;
                    textarea.value = intakeSession.fields[field.key] || '';
                    textarea.placeholder = `Enter ${field.label.toLowerCase()}...`;

                    wrapper.appendChild(label);
                    wrapper.appendChild(textarea);
                    intakeFieldsContainerEl.appendChild(wrapper);
                });
            };

            const hasAppointmentGenerationInput = (appointment) => {
                if (!appointment) return false;
                const hasSessionInfo = !!(appointment.sessionInfo || '').trim();
                const auditProofing = getAuditProofingData(appointment);
                const hasAuditProofing = Object.values(auditProofing).some(value => !!(value || '').trim());
                return hasSessionInfo || hasAuditProofing;
            };

            const runSoapAuditCheck = (client, appointment) => {
                const soap = appointment?.soap || {};
                const sectionText = {
                    s: (soap.s || '').trim(),
                    o: (soap.o || '').trim(),
                    a: (soap.a || '').trim(),
                    p: (soap.p || '').trim(),
                    i: (soap.interventions || '').trim()
                };

                const auditProofing = getAuditProofingData(appointment);
                const auditProofingText = `${auditProofing.symptoms}\n${auditProofing.functionalImpact}\n${auditProofing.progressResponse}\n${auditProofing.medicalNecessity}`.toLowerCase();

                const fullText = `${sectionText.s}\n${sectionText.o}\n${sectionText.a}\n${sectionText.p}\n${sectionText.i}`.toLowerCase();
                const sessionText = (appointment?.sessionInfo || '').toLowerCase();
                const combined = `${fullText}\n${sessionText}\n${auditProofingText}`;

                const checks = [
                    {
                        label: 'Subjective includes symptom detail',
                        pass: sectionText.s.length >= 20 && containsAny(sectionText.s.toLowerCase(), [/anx|depress|panic|sleep|mood|stress|irritab|fear|sad|worry|symptom/]),
                        remedy: 'Add symptom frequency/intensity language (for example, how often and how severe symptoms were this session).'
                    },
                    {
                        label: 'Subjective includes functional impact',
                        pass: containsAny(`${sectionText.s.toLowerCase()}\n${auditProofingText}`, [/work|school|relationship|parent|sleep|concentrat|avoid|function|impair/]),
                        remedy: 'Describe where symptoms impacted functioning (work, school, relationships, sleep, parenting, or daily tasks).'
                    },
                    {
                        label: 'Objective includes observable/MSE data',
                        pass: sectionText.o.length >= 20 && containsAny(sectionText.o.toLowerCase(), [/affect|mood|speech|oriented|orientation|appearance|behavior|thought|engaged|observed|denies/]),
                        remedy: 'Include at least 1â€“2 observed findings (appearance, affect, speech, orientation, thought process, engagement).'
                    },
                    {
                        label: 'Assessment states medical necessity/progress',
                        pass: sectionText.a.length >= 20 && containsAny(`${sectionText.a.toLowerCase()}\n${auditProofingText}`, [/medically necessary|continued|progress|partial|interfer|impair|deteriorat|required|diagnos|consistent with/]),
                        remedy: 'Add one sentence explaining why continued skilled treatment is needed now and what progress/remaining barriers were observed.'
                    },
                    {
                        label: 'Plan includes intervention + next step',
                        pass: sectionText.p.length >= 20 && containsAny(sectionText.p.toLowerCase(), [/continue|next session|follow-up|homework|assign|reassess|weekly|referral|coordinate|safety plan/]),
                        remedy: 'Add a concrete next-step plan (homework/follow-up/reassessment target) and tie it to ongoing symptoms.'
                    },
                    {
                        label: 'Interventions documented',
                        pass: sectionText.i.length >= 12 && sectionText.i.toLowerCase() !== 'no interventions identified.',
                        remedy: 'List techniques used today (for example CBT, reframing, exposure, grounding, psychoeducation) and client response.'
                    },
                    {
                        label: 'All SOAP sections completed',
                        pass: sectionText.s.length > 3 && sectionText.o.length > 3 && sectionText.a.length > 3 && sectionText.p.length > 3,
                        remedy: 'Complete S, O, A, and P with individualized content before finalizing.'
                    }
                ];

                const criticalLabels = new Set([
                    'All SOAP sections completed',
                    'Assessment states medical necessity/progress',
                    'Subjective includes functional impact'
                ]);

                const passedCount = checks.filter(check => check.pass).length;
                const score = Math.round((passedCount / checks.length) * 100);
                const failedCritical = checks.filter(check => !check.pass && criticalLabels.has(check.label));
                const likelyPass = score >= 80 && failedCritical.length === 0;

                return {
                    score,
                    likelyPass,
                    checks,
                    opportunities: checks.filter(check => !check.pass).map(check => check.remedy),
                    timestamp: new Date().toISOString(),
                    summary: likelyPass
                        ? 'Likely audit-ready based on configured SOAP criteria.'
                        : 'This note can be strengthened for stronger audit support. Suggested refinements are listed below.'
                };
            };

            const renderAuditResults = (auditResult) => {
                if (!auditResult) {
                    return `
                        <div class="audit-box">
                            <div style="font-size: 0.85rem; color: var(--text-color-secondary);">Run the audit check to evaluate this SOAP note against the audit guide criteria.</div>
                        </div>
                    `;
                }

                return `
                    <div class="audit-box">
                        <div class="audit-summary">
                            <span><strong>Audit Score:</strong> ${auditResult.score}%</span>
                            <span class="audit-badge ${auditResult.likelyPass ? 'pass' : 'fail'}">${auditResult.likelyPass ? 'Likely Pass' : 'Needs Revision'}</span>
                        </div>
                        <div style="font-size: 0.84rem; margin-bottom: 6px; color: var(--text-color-secondary);">${auditResult.summary}</div>
                        <ul class="audit-items">
                            ${auditResult.checks.map(check => `<li class="${check.pass ? 'audit-item-pass' : 'audit-item-fail'}">${check.pass ? 'âœ“' : 'âœ—'} ${check.label}</li>`).join('')}
                        </ul>
                        ${auditResult.opportunities && auditResult.opportunities.length > 0 ? `
                            <div class="audit-remediation">
                                <strong>Ways to strengthen this note:</strong>
                                <ul>
                                    ${auditResult.opportunities.map(item => `<li>${item}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
            };

            const getTreatmentGoalsContext = (client) => {
                if (!client?.goals?.length) return '';
                const activeGoals = client.goals.filter(g => g.status === 'active');
                if (activeGoals.length === 0) return '';
                return `\n- **Current Treatment Goals:**\n${activeGoals.map(goal => {
                    const objectives = goal.objectives && goal.objectives.length > 0
                        ? goal.objectives.map(obj => `  - ${obj.text} (${obj.completed ? 'Completed' : 'In Progress'}, ${obj.timelineMonths || 3} months)`).join('\n')
                        : '  - No specific objectives defined';
                    return `  â€¢ ${goal.title} (${goal.timelineMonths || 12} months)\n${objectives}`;
                }).join('\n')}\n`;
            };

            const getSelectedObjectivesContext = (client) => {
                if (!client?.goals?.length) return '';
                const objectives = client.goals
                    .filter(goal => goal.status === 'active')
                    .flatMap(goal => (goal.objectives || []).filter(obj => !obj.completed).map(obj => `${obj.text} (${obj.timelineMonths || 3} months)`));
                if (!objectives.length) return '';
                return `\n- **Priority Objectives:**\n${objectives.map(obj => `  - ${obj}`).join('\n')}`;
            };

            const getInterventionContext = (appointment) => {
                const bank = Array.isArray(data.interventionBank) ? data.interventionBank.filter(Boolean) : [];
                const selected = Array.isArray(appointment?.selectedInterventions)
                    ? appointment.selectedInterventions.filter(Boolean)
                    : [];
                let context = '';
                if (bank.length > 0) {
                    context += `\n- **Intervention Bank (Allowed Interventions Only):**\n${bank.map(item => `  - ${item}`).join('\n')}`;
                }
                if (selected.length > 0) {
                    context += `\n- **Previously Selected Interventions (From Bank):**\n${selected.map(item => `  - ${item}`).join('\n')}`;
                }
                return context;
            };

            const normalizeInterventionText = (text) => (text || '')
                .toString()
                .toLowerCase()
                .replace(/[^a-z0-9\s]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();

            const interventionStopWords = new Set(['and', 'or', 'the', 'with', 'for', 'to', 'of', 'in', 'on', 'a', 'an', 'by']);

            const selectInterventionsFromBank = (bank, aiInterventionsText, corpusText) => {
                if (!Array.isArray(bank) || bank.length === 0) return [];

                const normalizedCorpus = normalizeInterventionText(corpusText);
                const aiLines = (aiInterventionsText || '')
                    .split(/\n+/)
                    .map(line => normalizeInterventionText(line.replace(/^â€¢\s*/, '')))
                    .filter(Boolean);

                const selected = new Set();

                const bankMeta = bank
                    .filter(Boolean)
                    .map(item => {
                        const normalized = normalizeInterventionText(item);
                        const tokens = normalized
                            .split(' ')
                            .map(token => token.trim())
                            .filter(token => token.length > 2 && !interventionStopWords.has(token));
                        return { item, normalized, tokens };
                    })
                    .filter(entry => entry.normalized.length > 0);

                aiLines.forEach(line => {
                    bankMeta.forEach(entry => {
                        if (line === entry.normalized || line.includes(entry.normalized) || entry.normalized.includes(line)) {
                            selected.add(entry.item);
                        }
                    });
                });

                bankMeta.forEach(entry => {
                    if (!normalizedCorpus) return;
                    if (normalizedCorpus.includes(entry.normalized)) {
                        selected.add(entry.item);
                        return;
                    }

                    if (entry.tokens.length === 0) return;
                    if (entry.tokens.length === 1) {
                        if (normalizedCorpus.includes(entry.tokens[0])) {
                            selected.add(entry.item);
                        }
                        return;
                    }

                    const matchedCount = entry.tokens.filter(token => normalizedCorpus.includes(token)).length;
                    if (matchedCount >= Math.min(2, entry.tokens.length)) {
                        selected.add(entry.item);
                    }
                });

                return bank.filter(item => selected.has(item));
            };

            const appendAuditFieldToSection = (currentSectionText, label, value) => {
                const trimmedValue = (value || '').trim();
                if (!trimmedValue) return currentSectionText || '';
                const existing = currentSectionText || '';
                const normalizedExisting = existing.toLowerCase();
                const candidate = `${label}: ${trimmedValue}`;
                if (normalizedExisting.includes(candidate.toLowerCase())) {
                    return existing;
                }
                const prefix = existing.trim().length > 0 ? '\n' : '';
                return `${existing}${prefix}â€¢ ${candidate}`;
            };

            const getInstructionsContext = (client, appointment) => {
                const persistent = (client?.persistentInstructions || '').trim();
                const session = (appointment?.sessionInstructions || '').trim();

                let context = '';
                if (persistent) {
                    context += `\n- **Persistent Instructions (Client-Level):**\n${persistent}`;
                }
                if (session) {
                    context += `\n- **Session Instructions (Appointment-Level):**\n${session}`;
                }
                if (persistent && session) {
                    context += `\n- **Instruction Precedence Rule:** If Session Instructions conflict with Persistent Instructions, follow Session Instructions for this note.`;
                }
                return context;
            };

            const getModalitiesContext = (modalitiesInput, otherInput) => {
                const modalities = Array.isArray(modalitiesInput) ? [...new Set(modalitiesInput.filter(Boolean))] : [];
                const other = (otherInput || '').trim();
                const normalized = modalities.filter(m => m && m !== 'Other (Specify)');
                if (modalities.includes('Other (Specify)') && other) {
                    normalized.push(`Other: ${other}`);
                }
                if (!normalized.length) return '';
                return normalized;
            };

            const getGoalGenerationModalitiesContext = () => getModalitiesContext(goalGeneratorModalities, goalGeneratorModalityOther);

            const getClientGoalGenerationLens = (client) => {
                if (!client) {
                    return {
                        modalities: [...DEFAULT_GUIDING_MODALITIES],
                        other: ''
                    };
                }

                if (!client.goalGenerationLens || typeof client.goalGenerationLens !== 'object') {
                    client.goalGenerationLens = {
                        modalities: [...DEFAULT_GUIDING_MODALITIES],
                        other: ''
                    };
                }

                if (!Array.isArray(client.goalGenerationLens.modalities) || client.goalGenerationLens.modalities.length === 0) {
                    client.goalGenerationLens.modalities = [...DEFAULT_GUIDING_MODALITIES];
                }
                if (typeof client.goalGenerationLens.other !== 'string') {
                    client.goalGenerationLens.other = '';
                }

                return {
                    modalities: [...client.goalGenerationLens.modalities],
                    other: client.goalGenerationLens.other
                };
            };

            const saveClientGoalGenerationLens = () => {
                const client = findClient(selectedClientId);
                if (!client) return;

                client.goalGenerationLens = {
                    modalities: [...new Set((goalGeneratorModalities || []).filter(Boolean))],
                    other: goalGeneratorModalityOther || ''
                };
                markDirty();
            };

            const getClientSoapModalityContext = (client, appointment) => {
                const lens = getClientGoalGenerationLens(client);
                const modalities = getModalitiesContext(lens.modalities, lens.other);
                if (!modalities || modalities.length === 0) return '';

                const explicitInterventionSignals = [
                    (appointment?.sessionInfo || '').trim(),
                    ...((appointment?.selectedInterventions || []).map(item => item && item.trim()).filter(Boolean))
                ].filter(Boolean);

                return `
- **Client Modality Lens (Default):**
${modalities.map(item => `  - ${item}`).join('\n')}
- **Lens Rule:** Use the listed modalities as a default framing only when consistent with the session content.
- **Override Rule (Required):** If Session Information or selected interventions explicitly indicate a different modality/technique, preserve those interventions as written and do NOT force-fit them into the default lens.
${explicitInterventionSignals.length > 0 ? `- **Explicit Intervention Signals from Session Data:**\n${explicitInterventionSignals.map(item => `  - ${item}`).join('\n')}` : ''}`;
            };

            const renderInterventionBank = () => {
                if (!interventionBankList) return;
                interventionBankList.innerHTML = (data.interventionBank || []).map((item, index) => `
                    <div class="intervention-row">
                        <span>${item}</span>
                        <button class="action-btn delete-btn" data-bank-index="${index}" title="Remove intervention" style="width:20px;height:20px;">Ã—</button>
                    </div>
                `).join('');
            };

            const renderInterventionPicker = () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!appointment || !interventionPickerList) return;
                const selected = new Set(appointment.selectedInterventions || []);
                interventionPickerList.innerHTML = (data.interventionBank || []).map(item => `
                    <label class="intervention-row" style="cursor:pointer;">
                        <span>${item}</span>
                        <input type="checkbox" class="picker-intervention" value="${item.replace(/"/g, '&quot;')}" ${selected.has(item) ? 'checked' : ''}>
                    </label>
                `).join('');
            };

            const renderGuidingModalities = () => {
                if (!guidingModalitiesListEl || !guidingModalityOtherEl || !guidingModalityOtherWrapEl) return;

                if (!Array.isArray(goalGeneratorModalities) || goalGeneratorModalities.length === 0) {
                    goalGeneratorModalities = [...DEFAULT_GUIDING_MODALITIES];
                }

                guidingModalitiesListEl.innerHTML = goalGeneratorModalities.map((selectedModality, index) => `
                    <div class="modality-row" data-modality-index="${index}">
                        <select class="setting-input modality-select" data-modality-index="${index}">
                            ${GUIDING_MODALITY_OPTIONS.map(option => `<option value="${option.replace(/"/g, '&quot;')}" ${option === selectedModality ? 'selected' : ''}>${option}</option>`).join('')}
                        </select>
                        <button type="button" class="modality-row-btn add-modality-btn" title="Add modality">+</button>
                        <button type="button" class="modality-row-btn remove-modality-btn" title="Remove modality" ${goalGeneratorModalities.length <= 1 ? 'disabled' : ''}>âˆ’</button>
                    </div>
                `).join('');

                guidingModalityOtherEl.value = goalGeneratorModalityOther || '';
                const hasOtherSelected = goalGeneratorModalities.includes('Other (Specify)');
                guidingModalityOtherWrapEl.classList.toggle('hidden', !hasOtherSelected);
                guidingModalityOtherEl.disabled = !hasOtherSelected;
            };

            const saveGuidingModalities = () => {
                const selected = Array.from(guidingModalitiesListEl.querySelectorAll('.modality-select')).map(el => el.value);
                goalGeneratorModalities = selected.filter(Boolean);
                if (!goalGeneratorModalities.includes('Other (Specify)')) {
                    goalGeneratorModalityOther = '';
                    guidingModalityOtherEl.value = '';
                    guidingModalityOtherEl.disabled = true;
                    guidingModalityOtherWrapEl.classList.add('hidden');
                } else {
                    guidingModalityOtherWrapEl.classList.remove('hidden');
                    guidingModalityOtherEl.disabled = false;
                    goalGeneratorModalityOther = guidingModalityOtherEl.value || '';
                }
                saveClientGoalGenerationLens();
            };

            const renderCustomInstructionsModalities = () => {
                if (!customInstructionsModalitiesListEl || !customInstructionsModalityOtherWrapEl || !customInstructionsModalityOtherEl) return;

                if (!Array.isArray(goalGeneratorModalities) || goalGeneratorModalities.length === 0) {
                    goalGeneratorModalities = [...DEFAULT_GUIDING_MODALITIES];
                }

                customInstructionsModalitiesListEl.innerHTML = goalGeneratorModalities.map((selectedModality, index) => `
                    <div class="modality-row" data-modal-instructions-index="${index}">
                        <select class="setting-input custom-instructions-modality-select" data-modal-instructions-index="${index}">
                            ${GUIDING_MODALITY_OPTIONS.map(option => `<option value="${option.replace(/"/g, '&quot;')}" ${option === selectedModality ? 'selected' : ''}>${option}</option>`).join('')}
                        </select>
                        <button type="button" class="modality-row-btn add-custom-modality-btn" title="Add modality">+</button>
                        <button type="button" class="modality-row-btn remove-custom-modality-btn" title="Remove modality" ${goalGeneratorModalities.length <= 1 ? 'disabled' : ''}>âˆ’</button>
                    </div>
                `).join('');

                customInstructionsModalityOtherEl.value = goalGeneratorModalityOther || '';
                const hasOtherSelected = goalGeneratorModalities.includes('Other (Specify)');
                customInstructionsModalityOtherWrapEl.classList.toggle('hidden', !hasOtherSelected);
                customInstructionsModalityOtherEl.disabled = !hasOtherSelected;
            };

            const saveCustomInstructionsModalities = () => {
                const selected = Array.from(customInstructionsModalitiesListEl.querySelectorAll('.custom-instructions-modality-select')).map(el => el.value);
                goalGeneratorModalities = selected.filter(Boolean);
                if (!goalGeneratorModalities.includes('Other (Specify)')) {
                    goalGeneratorModalityOther = '';
                    customInstructionsModalityOtherEl.value = '';
                    customInstructionsModalityOtherEl.disabled = true;
                    customInstructionsModalityOtherWrapEl.classList.add('hidden');
                } else {
                    customInstructionsModalityOtherWrapEl.classList.remove('hidden');
                    customInstructionsModalityOtherEl.disabled = false;
                    goalGeneratorModalityOther = customInstructionsModalityOtherEl.value || '';
                }
                saveClientGoalGenerationLens();
            };

            const makeGoalText = (problem, index, modalities) => {
                const modalityHint = modalities[0] ? ` using ${modalities[0]}` : '';
                const templates = [
                    `Client will demonstrate improved management of ${problem}${modalityHint}, resulting in decreased symptom burden.`,
                    `Client will strengthen adaptive coping around ${problem}${modalityHint}, resulting in decreased functional impairment.`,
                    `Client will increase emotional regulation related to ${problem}${modalityHint}, resulting in decreased distress and improved stability.`,
                    `Client will improve consistency in healthy responses to ${problem}${modalityHint}, resulting in decreased escalation and improved daily functioning.`
                ];
                return templates[index % templates.length];
            };

            const makeObjectiveText = (problem, goalText, objectiveIndex, format, modalities) => {
                const modalityPhrase = modalities.length > 0 ? ` aligned with ${modalities[0]}` : '';
                if (format === 'smart') {
                    const smartTemplates = [
                        `Client will identify 2 triggers related to ${problem}${modalityPhrase} and document them in writing at least 3 days per week.`,
                        `Client will practice one coping strategy tied to ${goalText.toLowerCase()}${modalityPhrase} in at least 2 real-life situations each week.`,
                        `Client will track intensity of ${problem} symptoms weekly${modalityPhrase} and report trend changes during session.`,
                        `Client will use a structured self-regulation routine${modalityPhrase} and report at least 50% adherence by target review date.`
                    ];
                    return smartTemplates[objectiveIndex % smartTemplates.length];
                }

                const actionTemplates = [
                    `Client will identify patterns that maintain ${problem}${modalityPhrase} and discuss them in session.`,
                    `Client will identify and practice coping responses for ${problem}${modalityPhrase} between sessions.`,
                    `Client will identify barriers to progress${modalityPhrase} and use one replacement action in real-time.`,
                    `Client will identify gains and next steps${modalityPhrase} to sustain progress related to ${problem}.`
                ];
                return actionTemplates[objectiveIndex % actionTemplates.length];
            };

            const goalGenerationSystemPrompt = `You are assisting a mental health clinician with treatment-plan writing.

Return ONLY valid JSON in this exact shape:
{
  "goals": [
    {
      "title": "...",
      "timelineMonths": 12,
      "objectives": [
        {
          "text": "...",
          "timelineMonths": 3,
          "format": "action"
        }
      ]
    }
  ]
}

Requirements:
- Generate exactly the requested number of goals.
- Generate exactly the requested number of objectives per goal.
- Goal language: concise and outcome-focused, written as "Client will ... resulting in ...".
- Goals use 12-month timeline unless explicitly requested otherwise.
- Objectives use staggered timeline anchors across 3, 6, 9, 12 months.
- Objective text must be client-action focused.
- If objective format is "action", use action-oriented statements (for example: "Client will identify...").
- If objective format is "smart", produce SMART-style objective language.
- Use guiding modalities as conceptual framing when provided.
- Do NOT reference or imply any modality that is not explicitly selected.
- Do not include extra keys, commentary, markdown, or prose outside JSON.`;

            const MODALITY_TERM_MAP = {
                'CBT (Cognitive Behavioral Therapy)': ['CBT', 'Cognitive Behavioral Therapy'],
                'DBT (Dialectical Behavior Therapy)': ['DBT', 'Dialectical Behavior Therapy'],
                'ACT (Acceptance and Commitment Therapy)': ['ACT', 'Acceptance and Commitment Therapy'],
                'REBT (Rational Emotive Behavior Therapy)': ['REBT', 'Rational Emotive Behavior Therapy'],
                'CPT (Cognitive Processing Therapy)': ['CPT', 'Cognitive Processing Therapy'],
                'ERP (Exposure and Response Prevention)': ['ERP', 'Exposure and Response Prevention'],
                'Behavioral Activation (BA)': ['Behavioral Activation', 'BA'],
                'TF-CBT (Trauma-Focused CBT)': ['TF-CBT', 'Trauma-Focused CBT'],
                'Psychodynamic Psychotherapy': ['Psychodynamic Psychotherapy', 'Psychodynamic'],
                'Psychoanalysis': ['Psychoanalysis', 'Psychoanalytic'],
                'IFS (Internal Family Systems)': ['IFS', 'Internal Family Systems'],
                'Object Relations Therapy': ['Object Relations Therapy', 'Object Relations'],
                'Attachment-Based Therapy': ['Attachment-Based Therapy', 'Attachment Focused'],
                'EFT (Emotionally Focused Therapy)': ['EFT', 'Emotionally Focused Therapy'],
                'Person-Centered Therapy': ['Person-Centered Therapy', 'Client-Centered Therapy'],
                'Gestalt Therapy': ['Gestalt Therapy', 'Gestalt'],
                'Existential Therapy': ['Existential Therapy', 'Existential'],
                'Narrative Therapy': ['Narrative Therapy', 'Narrative'],
                'Solution-Focused Brief Therapy (SFBT)': ['SFBT', 'Solution-Focused Brief Therapy', 'Solution Focused'],
                'Logotherapy': ['Logotherapy']
            };

            const escapeRegExp = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            const sanitizeGoalTextByModalities = (text, selectedModalities) => {
                if (!text) return '';
                const selectedSet = new Set((selectedModalities || []).filter(item => !item.startsWith('Other:')));
                let sanitized = text;

                Object.entries(MODALITY_TERM_MAP).forEach(([option, terms]) => {
                    if (selectedSet.has(option)) return;
                    terms.forEach(term => {
                        const regex = new RegExp(`\\b${escapeRegExp(term)}\\b`, 'gi');
                        sanitized = sanitized.replace(regex, 'selected-modality');
                    });
                });

                return sanitized;
            };

            const extractJsonObject = (rawText) => {
                if (typeof rawText === 'object' && rawText !== null) {
                    return rawText;
                }
                const text = String(rawText || '').trim();
                const firstBrace = text.indexOf('{');
                const lastBrace = text.lastIndexOf('}');
                if (firstBrace === -1 || lastBrace === -1 || lastBrace < firstBrace) {
                    throw new Error('AI did not return a valid JSON object.');
                }
                const jsonText = text.slice(firstBrace, lastBrace + 1);
                return JSON.parse(jsonText);
            };

            const normalizeGoalDraftsFromAi = (aiPayload, problem, goalCount, objectiveCount, format, modalities) => {
                const staggeredTimeline = [3, 6, 9, 12];
                const aiGoals = Array.isArray(aiPayload?.goals) ? aiPayload.goals : [];
                const normalizedGoals = [];

                for (let goalIndex = 0; goalIndex < goalCount; goalIndex++) {
                    const aiGoal = aiGoals[goalIndex] || {};
                    const fallbackGoalTitle = makeGoalText(problem, goalIndex, modalities);
                    const goalTitle = (aiGoal.title || fallbackGoalTitle || '').toString().trim() || fallbackGoalTitle;
                    const timelineMonths = parseInt(aiGoal.timelineMonths, 10) || 12;

                    const aiObjectives = Array.isArray(aiGoal.objectives) ? aiGoal.objectives : [];
                    const objectives = [];
                    for (let objectiveIndex = 0; objectiveIndex < objectiveCount; objectiveIndex++) {
                        const aiObjective = aiObjectives[objectiveIndex] || {};
                        const fallbackObjectiveText = makeObjectiveText(problem, goalTitle, objectiveIndex, format, modalities);
                        const objectiveText = (aiObjective.text || fallbackObjectiveText || '').toString().trim() || fallbackObjectiveText;
                        const fallbackTimeline = staggeredTimeline[Math.min(objectiveIndex, staggeredTimeline.length - 1)];
                        const objectiveTimeline = parseInt(aiObjective.timelineMonths, 10) || fallbackTimeline;
                        const objectiveFormat = aiObjective.format === 'smart' ? 'smart' : format;

                        objectives.push({
                            id: crypto.randomUUID(),
                            approved: false,
                            text: sanitizeGoalTextByModalities(objectiveText, modalities),
                            timelineMonths: objectiveTimeline,
                            format: objectiveFormat,
                            completed: false,
                            dateCreated: new Date().toISOString()
                        });
                    }

                    normalizedGoals.push({
                        id: crypto.randomUUID(),
                        approved: false,
                        title: sanitizeGoalTextByModalities(goalTitle, modalities),
                        timelineMonths,
                        objectives
                    });
                }

                return normalizedGoals;
            };

            const fetchGoalDraftsFromAI = async (problem, goalCount, objectiveCount, format, modalities) => {
                if (!selectedModel) {
                    throw new Error('Please connect to a provider and select a model in Settings.');
                }

                const styleDescriptor = format === 'smart' ? 'smart' : 'action-focused';
                const selectedModalityOptions = modalities.filter(item => !item.startsWith('Other:'));
                const forbiddenModalityOptions = GUIDING_MODALITY_OPTIONS
                    .filter(item => item !== 'Other (Specify)' && !selectedModalityOptions.includes(item));
                const modalityContext = modalities.length > 0 ? modalities.map(item => `- ${item}`).join('\n') : '- None specified';
                const forbiddenContext = forbiddenModalityOptions.length > 0
                    ? forbiddenModalityOptions.map(item => `- ${item}`).join('\n')
                    : '- None';

                const userPrompt = `Problem/Diagnosis Focus:\n${problem}\n\nRequested Output:\n- Goals: ${goalCount}\n- Objectives per goal: ${objectiveCount}\n- Objective format: ${styleDescriptor}\n\nGuiding Modalities (Allowed):\n${modalityContext}\n\nForbidden Modalities (Do not use):\n${forbiddenContext}\n\nReturn only JSON in the required schema.`;

                if (apiProvider === 'vertex') {
                    if (!vertexServiceAccount || !vertexLocation) throw new Error('Please connect Vertex in Settings first.');

                    const accessToken = await getGoogleAccessToken(vertexServiceAccount);
                    const credentials = JSON.parse(vertexServiceAccount);
                    const projectId = credentials.project_id;

                    const payload = {
                        contents: [{ role: "user", parts: [{ text: `${goalGenerationSystemPrompt}\n\n${userPrompt}` }] }],
                        generationConfig: { responseMimeType: 'application/json' }
                    };

                    const normalizedLocation = (vertexLocation || '').toLowerCase();
                    const vertexHost = normalizedLocation === 'global'
                        ? 'aiplatform.googleapis.com'
                        : `${normalizedLocation}-aiplatform.googleapis.com`;

                    const callVertexDirect = async (modelId) => {
                        const url = `https://${vertexHost}/v1/projects/${projectId}/locations/${normalizedLocation}/publishers/google/models/${modelId}:generateContent`;
                        const response = await tauriFetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${accessToken}`
                            },
                            body: JSON.stringify(payload)
                        });
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`Vertex API error: ${response.status} - ${errorText}`);
                        }
                        const result = await response.json();
                        const content = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                        return extractJsonObject(content);
                    };

                    const primaryModel = selectedModel;
                    const modelsToTry = primaryModel === 'gemini-2.5-pro'
                        ? ['gemini-2.5-pro', 'gemini-1.5-pro']
                        : [primaryModel];

                    let lastError;
                    for (const modelId of modelsToTry) {
                        try {
                            return await callVertexDirect(modelId);
                        } catch (err) {
                            lastError = err;
                            console.warn(`Vertex goal generation failed for model ${modelId}`, err);
                        }
                    }

                    throw lastError;
                }

                if (apiProvider === 'openai') {
                    if (!openaiApiKey) throw new Error('Please connect OpenAI in Settings first.');
                    const payload = {
                        model: selectedModel,
                        messages: [
                            { role: 'system', content: goalGenerationSystemPrompt },
                            { role: 'user', content: userPrompt }
                        ],
                        response_format: { type: 'json_object' }
                    };
                    const response = await tauriFetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiApiKey}`
                        },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`OpenAI API error: ${response.status} - ${errorData?.error?.message || 'Unknown error'}`);
                    }
                    const result = await response.json();
                    const content = result?.choices?.[0]?.message?.content;
                    return extractJsonObject(content);
                }

                if (apiProvider === 'openwebui') {
                    if (!serverAddress) throw new Error('Please connect Open WebUI in Settings first.');
                    const payload = {
                        model: selectedModel,
                        messages: [
                            { role: 'system', content: goalGenerationSystemPrompt },
                            { role: 'user', content: userPrompt }
                        ],
                        response_format: { type: 'json_object' },
                        stream: false
                    };
                    const headers = new Headers({ 'Content-Type': 'application/json' });
                    if (apiKey) headers.append('Authorization', `Bearer ${apiKey}`);
                    const response = await tauriFetch(`${serverAddress}/api/v1/chat/completions`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(payload),
                        mode: 'cors'
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Open WebUI API error: ${response.status} - ${errorText}`);
                    }
                    const result = await response.json();
                    const content = result?.choices?.[0]?.message?.content;
                    return extractJsonObject(content);
                }

                if (apiProvider === 'ollama') {
                    const address = (ollamaAddressInput.value || '').trim();
                    if (!address) throw new Error('Please connect Ollama in Settings first.');
                    const base = address.endsWith('/') ? address.slice(0, -1) : address;
                    const payload = {
                        model: selectedModel,
                        messages: [
                            { role: 'system', content: goalGenerationSystemPrompt },
                            { role: 'user', content: userPrompt }
                        ],
                        response_format: { type: 'json_object' },
                        stream: false
                    };

                    const response = await tauriFetch(`${base}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Ollama API error: ${response.status} - ${errorText}`);
                    }
                    const result = await response.json();
                    const content = result?.choices?.[0]?.message?.content;
                    return extractJsonObject(content);
                }

                throw new Error('Invalid API provider selected.');
            };

            const generateGoalDrafts = async () => {
                const problem = (goalProblemInput.value || '').trim();
                const goalCount = Math.max(1, Math.min(8, parseInt(goalCountInput.value, 10) || 1));
                const objectiveCount = Math.max(1, Math.min(6, parseInt(objectiveCountInput.value, 10) || 1));
                const format = objectiveStyleSelect.value === 'smart' ? 'smart' : 'action';
                const modalities = getGoalGenerationModalitiesContext();
                saveClientGoalGenerationLens();

                if (!problem) {
                    alert('Please enter a problem/diagnosis focus first.');
                    return;
                }

                runGoalGeneratorBtn.disabled = true;
                runGoalGeneratorBtn.textContent = 'Generating...';

                try {
                    const aiPayload = await fetchGoalDraftsFromAI(problem, goalCount, objectiveCount, format, modalities);
                    generatedGoalsDraft = normalizeGoalDraftsFromAi(aiPayload, problem, goalCount, objectiveCount, format, modalities);
                    renderGeneratedGoalsReview();
                } catch (error) {
                    console.error('Goal generation error:', error);
                    alert(`Failed to generate goals/objectives with AI. ${error.message}`);
                } finally {
                    runGoalGeneratorBtn.disabled = false;
                    runGoalGeneratorBtn.textContent = 'Generate Draft';
                }
            };

            const renderGeneratedGoalsReview = () => {
                if (!generatedGoalsReview) return;
                if (!generatedGoalsDraft.length) {
                    generatedGoalsReview.innerHTML = '<div class="no-selection">Generate a draft to review, edit, and approve.</div>';
                    applyGeneratedGoalsBtn.disabled = true;
                    return;
                }

                generatedGoalsReview.innerHTML = generatedGoalsDraft.map((goal, goalIndex) => `
                    <div class="generator-card" data-draft-goal-index="${goalIndex}">
                        <div class="generator-title">Goal ${goalIndex + 1}</div>
                        <div style="display:grid;grid-template-columns:1fr 110px 120px;gap:8px;align-items:end;margin-bottom:8px;">
                            <div>
                                <label style="font-size:0.82rem;font-weight:600;display:block;margin-bottom:4px;">Goal Text</label>
                                <textarea class="mini-input draft-goal-text" rows="2">${goal.title}</textarea>
                            </div>
                            <div>
                                <label style="font-size:0.82rem;font-weight:600;display:block;margin-bottom:4px;">Timeline (mo)</label>
                                <input type="number" class="mini-input draft-goal-timeline" min="1" max="24" value="${goal.timelineMonths || 12}">
                            </div>
                            <label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;">
                                <input type="checkbox" class="draft-goal-approved" ${goal.approved ? 'checked' : ''}> Approve Goal
                            </label>
                        </div>
                        ${(goal.objectives || []).map((obj, objIndex) => `
                            <div style="display:grid;grid-template-columns:1fr 110px 140px;gap:8px;align-items:end;margin:6px 0 0 0;" data-draft-objective-index="${objIndex}">
                                <div>
                                    <label style="font-size:0.8rem;font-weight:600;display:block;margin-bottom:4px;">Objective ${objIndex + 1}</label>
                                    <textarea class="mini-input draft-obj-text" rows="2">${obj.text}</textarea>
                                </div>
                                <div>
                                    <label style="font-size:0.8rem;font-weight:600;display:block;margin-bottom:4px;">Timeline (mo)</label>
                                    <input type="number" class="mini-input draft-obj-timeline" min="1" max="24" value="${obj.timelineMonths || 3}">
                                </div>
                                <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
                                    <select class="mini-input draft-obj-format" style="max-width:120px;">
                                        <option value="action" ${obj.format === 'action' ? 'selected' : ''}>Action</option>
                                        <option value="smart" ${obj.format === 'smart' ? 'selected' : ''}>SMART</option>
                                    </select>
                                    <label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;white-space:nowrap;">
                                        <input type="checkbox" class="draft-obj-approved" ${obj.approved ? 'checked' : ''}> Approve
                                    </label>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `).join('');

                syncGeneratedGoalsFromReview();
            };

            const syncGeneratedGoalsFromReview = () => {
                const goalCards = Array.from(generatedGoalsReview.querySelectorAll('[data-draft-goal-index]'));
                goalCards.forEach(card => {
                    const goalIndex = parseInt(card.dataset.draftGoalIndex, 10);
                    const draftGoal = generatedGoalsDraft[goalIndex];
                    if (!draftGoal) return;

                    draftGoal.title = (card.querySelector('.draft-goal-text')?.value || '').trim();
                    draftGoal.timelineMonths = parseInt(card.querySelector('.draft-goal-timeline')?.value || '12', 10) || 12;
                    draftGoal.approved = !!card.querySelector('.draft-goal-approved')?.checked;

                    const objectiveRows = Array.from(card.querySelectorAll('[data-draft-objective-index]'));
                    objectiveRows.forEach(row => {
                        const objIndex = parseInt(row.dataset.draftObjectiveIndex, 10);
                        const draftObj = draftGoal.objectives?.[objIndex];
                        if (!draftObj) return;
                        draftObj.text = (row.querySelector('.draft-obj-text')?.value || '').trim();
                        draftObj.timelineMonths = parseInt(row.querySelector('.draft-obj-timeline')?.value || '3', 10) || 3;
                        draftObj.format = row.querySelector('.draft-obj-format')?.value === 'smart' ? 'smart' : 'action';
                        draftObj.approved = !!row.querySelector('.draft-obj-approved')?.checked;
                    });
                });

                applyGeneratedGoalsBtn.disabled = generatedGoalsDraft.length === 0;
            };

            const applyGeneratedGoals = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                syncGeneratedGoalsFromReview();

                const approvedGoals = generatedGoalsDraft
                    .filter(goal => goal.approved && (goal.title || '').trim())
                    .map(goal => ({
                        ...goal,
                        objectives: (goal.objectives || []).filter(obj => obj.approved && (obj.text || '').trim())
                    }))
                    .filter(goal => goal.objectives.length > 0);

                if (approvedGoals.length === 0) {
                    alert('Approve at least one goal and one objective under it, then click Apply Approved Goals.');
                    return;
                }

                if (!Array.isArray(client.goals)) client.goals = [];
                approvedGoals.forEach(draftGoal => {
                    client.goals.push({
                        id: crypto.randomUUID(),
                        title: draftGoal.title,
                        timelineMonths: draftGoal.timelineMonths,
                        status: 'active',
                        objectives: (draftGoal.objectives || []).map(obj => ({
                            id: crypto.randomUUID(),
                            text: obj.text,
                            timelineMonths: obj.timelineMonths,
                            format: obj.format,
                            completed: false,
                            dateCreated: new Date().toISOString()
                        })),
                        dateCreated: new Date().toISOString()
                    });
                });

                generatedGoalsDraft = [];
                renderGeneratedGoalsReview();
                goalGeneratorModal.classList.add('hidden');
                markDirty();
                renderGoals();
            };
            
            // --- UI Rendering ---
            const renderClients = () => {
                // Note: Drag and drop reordering means we can't sort here anymore.
                // The array order is now the source of truth for display order.
                const clients = data.clients; 
                if (clients.length === 0) {
                    clientListEl.innerHTML = '<div class="no-selection">Click + to add a client</div>';
                    return;
                }
                clientListEl.innerHTML = clients.map(client => `
                    <div class="client-item ${client.id === selectedClientId ? 'active' : ''}" data-client-id="${client.id}">
                        ${client.name}
                        <div class="action-buttons">
                            <button class="action-btn edit-btn" title="Edit Name">âœï¸</button>
                            <button class="action-btn archive-btn" title="Archive Client">A</button>
                            <button class="action-btn delete-btn" title="Delete Client">Ã—</button>
                        </div>
                    </div>
                `).join('');
            };

            const renderAppointments = () => {
                const client = findClient(selectedClientId);
                addAppointmentBtn.disabled = !client;
                addIntakeBtn.disabled = !client;
                addNoteBtn.disabled = !client;
                if (!client) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Select a client first</div>';
                    return;
                }

                if (!Array.isArray(client.notes)) client.notes = [];
                if (!Array.isArray(client.intakeSessions)) client.intakeSessions = [];
                const appointments = (client.appointments || []).sort((a, b) => new Date(b.date) - new Date(a.date));
                const notes = (client.notes || []).slice().sort((a, b) => new Date(b.updatedAt || b.createdAt || 0) - new Date(a.updatedAt || a.createdAt || 0));
                const intakeSessions = (client.intakeSessions || []).slice().sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0));

                if (appointments.length === 0 && intakeSessions.length === 0 && notes.length === 0) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Click + to add appointment, intake session, or note</div>';
                    return;
                }

                const appointmentsHtml = appointments.length > 0 ? `
                    <div class="list-subheader">Appointments</div>
                    ${appointments.map(appt => `
                        <div class="appointment-item ${appt.id === selectedAppointmentId ? 'active' : ''}" data-appointment-id="${appt.id}">
                            <div class="appointment-date">${new Date(appt.date).toLocaleDateString()}</div>
                            <div class="action-buttons">
                                <button class="action-btn delete-btn" title="Delete Appointment">Ã—</button>
                            </div>
                        </div>
                    `).join('')}
                ` : '';

                const notesHtml = notes.length > 0 ? `
                    <div class="list-subheader">Notes</div>
                    ${notes.map(note => `
                        <div class="note-item ${note.id === selectedNoteId ? 'active' : ''}" data-note-id="${note.id}">
                            <div class="note-name">ðŸ“ ${note.name}</div>
                            <div class="action-buttons">
                                <button class="action-btn edit-btn" title="Rename Note">âœï¸</button>
                                <button class="action-btn delete-btn" title="Delete Note">Ã—</button>
                            </div>
                        </div>
                    `).join('')}
                ` : '';

                const intakeHtml = intakeSessions.length > 0 ? `
                    <div class="list-subheader">Intake Sessions</div>
                    ${intakeSessions.map(intake => `
                        <div class="intake-item ${intake.id === selectedIntakeId ? 'active' : ''}" data-intake-id="${intake.id}">
                            <div class="note-name">ðŸ“‹ Intake Session ${new Date(intake.createdAt).toLocaleDateString()}</div>
                            <div class="action-buttons">
                                <button class="action-btn delete-btn" title="Delete Intake Session">Ã—</button>
                            </div>
                        </div>
                    `).join('')}
                ` : '';

                appointmentListEl.innerHTML = `${appointmentsHtml}${intakeHtml}${notesHtml}`;
            };

            const renderDetails = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;
                const note = client ? findNote(client, selectedNoteId) : null;
                const intakeSession = client ? findIntakeSession(client, selectedIntakeId) : null;
                
                persistentNotesEl.disabled = !client;
                persistentNotesEl.value = client ? client.persistentNotes || '' : '';
                persistentNotesEl.placeholder = client ? "Enter persistent notes for this client..." : "Select a client to enter persistent notes...";

                clientDiagnosisEl.disabled = !client;
                clientDiagnosisEl.value = client ? client.diagnosis || '' : '';
                clientDiagnosisEl.placeholder = client ? "Enter client diagnoses here for reference..." : "Select a client to enter diagnoses...";

                sessionInfoEl.disabled = !appointment && !note;
                sessionInfoEl.value = appointment
                    ? appointment.sessionInfo || ''
                    : (note ? note.sessionInfo || '' : '');
                sessionInfoEl.placeholder = appointment
                    ? "Enter session details..."
                    : (note ? "Enter freeform note details..." : "Select an appointment or note to begin...");

                const isNoteMode = !appointment && !!note && !intakeSession;
                if (appointment || isNoteMode) {
                    sessionInfoEl.rows = 20;
                    sessionInfoEl.style.minHeight = '20lh';
                    sessionInfoEl.style.resize = 'vertical';
                    sessionInfoEl.style.width = '100%';
                    sessionInfoEl.style.flex = isNoteMode ? '1 1 auto' : '0 0 auto';
                } else {
                    sessionInfoEl.rows = 8;
                    sessionInfoEl.style.minHeight = '';
                    sessionInfoEl.style.resize = 'vertical';
                    sessionInfoEl.style.width = '100%';
                    sessionInfoEl.style.flex = '0 0 auto';
                }

                regularSessionFieldsEl.classList.toggle('hidden', !!intakeSession);
                intakeSessionBlockEl.classList.toggle('hidden', !intakeSession);
                auditProofingBlockEl.classList.toggle('hidden', !appointment);
                renderIntakeFields(intakeSession);

                const auditProofing = getAuditProofingData(appointment);
                [
                    auditProofSymptomsEl,
                    auditProofFunctionalEl,
                    auditProofProgressEl,
                    auditProofNecessityEl
                ].forEach(field => {
                    field.disabled = !appointment;
                });
                auditProofSymptomsEl.value = appointment ? auditProofing.symptoms : '';
                auditProofFunctionalEl.value = appointment ? auditProofing.functionalImpact : '';
                auditProofProgressEl.value = appointment ? auditProofing.progressResponse : '';
                auditProofNecessityEl.value = appointment ? auditProofing.medicalNecessity : '';
                
                persistentInstructions = client ? client.persistentInstructions || '' : '';
                sessionInstructions = appointment ? appointment.sessionInstructions || '' : '';
                customInstructionsBtn.disabled = !client;
                
                updateAppointmentDateBtn.disabled = !appointment;
                addAppointmentBtn.disabled = !client;
                addIntakeBtn.disabled = !client;
                renameNoteBtn.disabled = !note;
                noteNameInput.disabled = !client;
                generateGoalsBtn.disabled = !client;

                sessionTimerWrapper.style.display = appointment ? 'block' : 'none';
                if (appointment) {
                    renderSessionTimer(appointment);
                }

                renderGoals();
                renderSoap();
                
                generateNoteBtn.disabled = !appointment || !hasAppointmentGenerationInput(appointment);
            };

            const renderGoals = () => {
                const client = findClient(selectedClientId);
                addGoalBtnInTab.disabled = !client;
                generateGoalsBtn.disabled = !client;
                
                if (!client) {
                    goalsListInTabEl.innerHTML = '<div class="no-selection">Select a client to manage goals</div>';
                    return;
                }

                if (!client.goals) {
                    client.goals = [];
                }

                if (client.goals.length === 0) {
                    goalsListInTabEl.innerHTML = '<div class="no-selection">Click + to add a treatment goal</div>';
                    return;
                }

                goalsListInTabEl.innerHTML = client.goals.map(goal => `
                    <div class="goal-item" data-goal-id="${goal.id}">
                        <div class="goal-header">
                            <div class="goal-title">${goal.title}</div>
                            <div style="display: flex; align-items: center;">
                                <div class="goal-status" style="margin-right: 8px;">${goal.timelineMonths || 12} mo</div>
                                <div class="goal-status ${goal.status}">${goal.status.charAt(0).toUpperCase() + goal.status.slice(1)}</div>
                                <div class="goal-actions">
                                    <button class="action-btn edit-btn" title="Edit Goal">âœï¸</button>
                                    <button class="action-btn timeline-btn" title="Edit Goal Timeline">â±</button>
                                    <button class="action-btn archive-btn" title="Change Status">âš¡</button>
                                    <button class="action-btn delete-btn" title="Delete Goal">Ã—</button>
                                </div>
                            </div>
                        </div>
                        <div class="objective-list">
                            ${(goal.objectives || []).map(obj => `
                                <div class="objective-item" data-objective-id="${obj.id}">
                                    <input type="checkbox" class="objective-checkbox" ${obj.completed ? 'checked' : ''}>
                                    <span class="objective-text ${obj.completed ? 'completed' : ''}">${obj.text}</span>
                                    <span class="goal-status" style="margin-left: 6px;">${obj.timelineMonths || 3} mo</span>
                                    <button class="action-btn edit-objective-btn" title="Edit Objective" style="opacity: 0; width: 16px; height: 16px; font-size: 10px; background:#3498db;">âœï¸</button>
                                    <button class="action-btn timeline-objective-btn" title="Edit Objective Timeline" style="opacity: 0; width: 16px; height: 16px; font-size: 10px; background:#e67e22;">â±</button>
                                    <button class="action-btn delete-btn" title="Delete Objective" style="opacity: 0; width: 16px; height: 16px; font-size: 10px;">Ã—</button>
                                </div>
                            `).join('')}
                            <button class="add-objective-btn" data-goal-id="${goal.id}">+ Add Objective</button>
                        </div>
                    </div>
                `).join('');
            };
            
            const renderSessionTimer = (appointment) => {
                clearInterval(sessionTimerInterval);

                if (appointment.startTime) {
                    startTimerBtn.textContent = `Start: ${new Date(appointment.startTime).toLocaleTimeString()}`;
                } else {
                    startTimerBtn.textContent = 'Start';
                }

                if (appointment.endTime) {
                    stopTimerBtn.textContent = `End: ${new Date(appointment.endTime).toLocaleTimeString()}`;
                } else {
                    stopTimerBtn.textContent = 'Stop';
                }

                const updateDuration = () => {
                    if (!appointment.startTime) {
                        sessionDurationEl.textContent = '00:00';
                        return;
                    }
                    
                    const start = new Date(appointment.startTime);
                    const end = appointment.endTime ? new Date(appointment.endTime) : new Date();
                    
                    let totalSeconds = Math.floor((end - start) / 1000);
                    if (totalSeconds < 0) totalSeconds = 0;

                    const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                    const seconds = (totalSeconds % 60).toString().padStart(2, '0');
                    
                    sessionDurationEl.textContent = `${minutes}:${seconds}`;
                };

                updateDuration();

                // If the timer is running (start time exists but no end time), set an interval to update it.
                if (appointment.startTime && !appointment.endTime) {
                    sessionTimerInterval = setInterval(updateDuration, 1000);
                }
            };

            const renderSoap = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;
                const note = client ? findNote(client, selectedNoteId) : null;
                const intakeSession = client ? findIntakeSession(client, selectedIntakeId) : null;

                if (!appointment) {
                    if (intakeSession) {
                        soapContentEl.innerHTML = '<div class="no-selection">Selected item is an Intake Session. Intake sessions do not qualify for generated SOAP notes.</div>';
                        return;
                    }
                    if (note) {
                        soapContentEl.innerHTML = '<div class="no-selection">Selected item is a Note. SOAP note generation and SOAP editing are disabled for Notes.</div>';
                        return;
                    }
                    soapContentEl.innerHTML = '<div class="no-selection">Select an appointment to begin</div>';
                    return;
                }

                const soapData = appointment.soap || { s: '', o: '', a: '', p: '' };
                if (!Array.isArray(appointment.selectedInterventions)) appointment.selectedInterventions = [];
                const interventions = appointment.selectedInterventions.length > 0
                    ? appointment.selectedInterventions.map(item => `â€¢ ${item}`).join('\n')
                    : (soapData.interventions || 'No interventions selected from the bank.');
                const auditResult = appointment.auditCheck || null;
                soapContentEl.innerHTML = `
                    <div class="soap-section">
                        <div class="soap-header"><span>Subjective</span><button class="copy-btn" data-target="soapS">Copy</button></div>
                        <textarea id="soapS" class="soap-textarea" placeholder="â€¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.s || ''}</textarea>
                        ${(soapData.s_suggestion || []).map((s, i) => renderSuggestionBox('s', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Objective</span><button class="copy-btn" data-target="soapO">Copy</button></div>
                        <textarea id="soapO" class="soap-textarea" placeholder="â€¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.o || ''}</textarea>
                        ${(soapData.o_suggestion || []).map((s, i) => renderSuggestionBox('o', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Assessment</span><button class="copy-btn" data-target="soapA">Copy</button></div>
                        <textarea id="soapA" class="soap-textarea" placeholder="â€¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.a || ''}</textarea>
                        ${(soapData.a_suggestion || []).map((s, i) => renderSuggestionBox('a', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Plan</span><button class="copy-btn" data-target="soapP">Copy</button></div>
                        <textarea id="soapP" class="soap-textarea" placeholder="â€¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.p || ''}</textarea>
                        ${(soapData.p_suggestion || []).map((s, i) => renderSuggestionBox('p', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Interventions</span><div><button id="selectInterventionsBtn" class="copy-btn" style="margin-right:6px;">Select from Bank</button><button class="copy-btn" data-target="interventions">Copy</button></div></div>
                        <textarea id="interventions" class="soap-textarea" readonly autocorrect="off" autocapitalize="off" spellcheck="true">${interventions}</textarea>
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Audit Check</span><button id="runSoapAuditBtn" class="copy-btn">Run Audit Check</button></div>
                        ${renderAuditResults(auditResult)}
                    </div>`;
                
                // After rendering, resize all textareas
                soapContentEl.querySelectorAll('.soap-textarea').forEach(el => {
                    if (!el.readOnly) { // Don't auto-resize the read-only interventions box
                        autoResizeTextarea(el);
                    }
                });
            };

            const renderSuggestionBox = (type, suggestion, index) => {
                if (!suggestion) return '';

                let suggestionTitle;
                let suggestionContent;
                let actionsHtml;

                const isReplacement = typeof suggestion === 'object' && suggestion.original && suggestion.suggested;

                if (isReplacement) {
                    suggestionTitle = 'Clinical Language Suggestion:';
                    suggestionContent = `
                        <div><strong>Original:</strong> ${suggestion.original}</div>
                        <div style="margin-top: 4px;"><strong>Suggested:</strong> ${suggestion.suggested}</div>
                    `;
                    actionsHtml = `
                        <button class="suggestion-decline">Keep Original</button>
                        <button class="suggestion-accept-replace">Use Suggestion</button>
                    `;
                } else { // It's a new suggestion (string)
                    suggestionTitle = 'Suggestion for Addition:';
                    suggestionContent = `<strong>${suggestionTitle}</strong> ${suggestion}`;
                    actionsHtml = `
                        <button class="suggestion-accept">Accept</button>
                        <button class="suggestion-decline">Decline</button>
                    `;
                }

                return `
                    <div class="suggestion-box" data-suggestion-type="${type}" data-suggestion-index="${index}">
                        <div class="suggestion-text">${suggestionContent}</div>
                        <div class="suggestion-actions">
                            ${actionsHtml}
                        </div>
                    </div>
                `;
            };

            const renderDeletedLists = () => {
                deletedClientsListEl.innerHTML = '';
                clearDeletedClientsBtn.classList.toggle('hidden', deletedItems.clients.length === 0);
                deletedItems.clients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Restore</button>`;
                    deletedClientsListEl.appendChild(div);
                });

                deletedAppointmentsListEl.innerHTML = '';
                 clearDeletedAppointmentsBtn.classList.toggle('hidden', deletedItems.appointments.length === 0);
                deletedItems.appointments.forEach(appt => {
                    const clientName = findClient(appt.clientId)?.name?.substring(0, 5) + '...' || 'N/A';
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${new Date(appt.date).toLocaleDateString()} (${clientName})</span><button class="restore-btn" data-id="${appt.id}">Restore</button>`;
                    deletedAppointmentsListEl.appendChild(div);
                });
            };

            const renderArchivedClients = () => {
                archivedClientsListEl.innerHTML = '';
                (data.archivedClients || []).forEach(client => {
                     const div = document.createElement('div');
                     div.className = 'deleted-item';
                     div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Unarchive</button>`;
                     archivedClientsListEl.appendChild(div);
                });
            };

            const fullRender = () => {
                renderClients();
                renderAppointments();
                renderDetails();
                renderDeletedLists();
                renderArchivedClients();
            };

            // --- Event Handlers & Actions ---
            const selectClient = (id) => {
                selectedClientId = id;
                selectedAppointmentId = null;
                selectedNoteId = null;
                selectedIntakeId = null;
                clearInterval(sessionTimerInterval); // Stop timer when switching clients
                fullRender();
            };

            const selectAppointment = (id) => {
                selectedAppointmentId = id;
                selectedNoteId = null;
                selectedIntakeId = null;
                fullRender();
            };

            const selectNote = (id) => {
                selectedNoteId = id;
                selectedAppointmentId = null;
                selectedIntakeId = null;
                fullRender();
            };

            const selectIntakeSession = (id) => {
                selectedIntakeId = id;
                selectedAppointmentId = null;
                selectedNoteId = null;
                fullRender();
            };

            const addGoal = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const title = prompt("Enter goal title:");
                if (!title || !title.trim()) return;
                
                const newGoal = {
                    id: crypto.randomUUID(),
                    title: title.trim(),
                    timelineMonths: 12,
                    status: 'active',
                    objectives: [],
                    dateCreated: new Date().toISOString()
                };
                
                if (!client.goals) client.goals = [];
                client.goals.push(newGoal);
                markDirty();
                renderGoals();
            };

            const addObjective = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const text = prompt("Enter objective:");
                if (!text || !text.trim()) return;
                
                const newObjective = {
                    id: crypto.randomUUID(),
                    text: text.trim(),
                    timelineMonths: 3,
                    format: 'action',
                    completed: false,
                    dateCreated: new Date().toISOString()
                };
                
                if (!goal.objectives) goal.objectives = [];
                goal.objectives.push(newObjective);
                markDirty();
                renderGoals();
            };

            const toggleObjective = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const objective = goal.objectives.find(o => o.id === objectiveId);
                if (!objective) return;
                
                objective.completed = !objective.completed;
                if (objective.completed) {
                    objective.dateCompleted = new Date().toISOString();
                } else {
                    delete objective.dateCompleted;
                }
                
                markDirty();
                renderGoals();
            };

            const deleteGoal = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goalIndex = client.goals.findIndex(g => g.id === goalId);
                if (goalIndex === -1) return;
                
                const goal = client.goals[goalIndex];
                if (confirm(`Are you sure you want to delete the goal "${goal.title}"?`)) {
                    client.goals.splice(goalIndex, 1);
                    markDirty();
                    renderGoals();
                }
            };

            const deleteObjective = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const objIndex = goal.objectives.findIndex(o => o.id === objectiveId);
                if (objIndex === -1) return;
                
                goal.objectives.splice(objIndex, 1);
                markDirty();
                renderGoals();
            };

            const changeGoalStatus = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const statuses = ['active', 'completed', 'discontinued'];
                const currentIndex = statuses.indexOf(goal.status);
                const nextIndex = (currentIndex + 1) % statuses.length;
                
                goal.status = statuses[nextIndex];
                if (goal.status === 'completed') {
                    goal.dateCompleted = new Date().toISOString();
                } else {
                    delete goal.dateCompleted;
                }
                
                markDirty();
                renderGoals();
            };

            const editGoal = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const newTitle = prompt("Edit goal title:", goal.title);
                if (newTitle && newTitle.trim() && newTitle.trim() !== goal.title) {
                    goal.title = newTitle.trim();
                    markDirty();
                    renderGoals();
                }
            };

            const editGoalTimeline = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;

                const response = prompt('Goal timeline (months):', String(goal.timelineMonths || 12));
                if (response === null) return;
                const months = Math.max(1, Math.min(36, parseInt(response, 10) || 12));
                goal.timelineMonths = months;
                markDirty();
                renderGoals();
            };

            const editObjective = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                const objective = goal.objectives.find(o => o.id === objectiveId);
                if (!objective) return;

                const response = prompt('Edit objective:', objective.text);
                if (response && response.trim()) {
                    objective.text = response.trim();
                    markDirty();
                    renderGoals();
                }
            };

            const editObjectiveTimeline = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                const objective = goal.objectives.find(o => o.id === objectiveId);
                if (!objective) return;

                const response = prompt('Objective timeline (months):', String(objective.timelineMonths || 3));
                if (response === null) return;
                objective.timelineMonths = Math.max(1, Math.min(36, parseInt(response, 10) || 3));
                markDirty();
                renderGoals();
            };

            const createClient = (name) => {
                if (!name || !name.trim()) return;
                const newClient = {
                    id: crypto.randomUUID(),
                    name: name.trim(),
                    persistentNotes: '',
                    persistentInstructions: '',
                    appointments: [],
                    intakeSessions: [],
                    notes: [],
                    goals: [],
                    goalGenerationLens: {
                        modalities: [...DEFAULT_GUIDING_MODALITIES],
                        other: ''
                    }
                };
                data.clients.push(newClient);
                selectClient(newClient.id);
                markDirty();
            };

            const openAddClientModal = () => {
                addClientNameInput.value = '';
                addClientModal.classList.remove('hidden');
                setTimeout(() => addClientNameInput.focus(), 0);
            };

            const closeAddClientModal = () => {
                addClientModal.classList.add('hidden');
            };

            const addClient = () => {
                const name = (addClientNameInput.value || '').trim();
                if (!name) return;
                createClient(name);
                closeAddClientModal();
            };

            const addAppointment = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const date = appointmentDateInput.value;
                if (!date) {
                    alert('Please select a date for the appointment.');
                    return;
                }
                const dateObj = new Date(date);
                const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());

                const newAppointment = {
                    id: crypto.randomUUID(),
                    date: utcDate.toISOString(),
                    sessionInfo: '',
                    sessionInstructions: '',
                    selectedInterventions: [],
                    startTime: null,
                    endTime: null,
                    soap: { s: '', o: '', a: '', p: '' }
                };
                client.appointments.push(newAppointment);
                selectAppointment(newAppointment.id);
                markDirty();
            };

            const addNote = () => {
                const client = findClient(selectedClientId);
                if (!client) return;

                const name = noteNameInput.value.trim();
                if (!name) {
                    alert('Please enter a note name.');
                    return;
                }

                if (!Array.isArray(client.notes)) client.notes = [];
                const newNote = {
                    id: crypto.randomUUID(),
                    name,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                client.notes.push(newNote);
                noteNameInput.value = '';
                selectNote(newNote.id);
                markDirty();
            };

            const addIntakeSession = () => {
                const client = findClient(selectedClientId);
                if (!client) return;

                if (!Array.isArray(client.intakeSessions)) client.intakeSessions = [];
                const newIntakeSession = {
                    id: crypto.randomUUID(),
                    createdAt: new Date().toISOString(),
                    fields: {}
                };

                client.intakeSessions.push(newIntakeSession);
                selectIntakeSession(newIntakeSession.id);
                markDirty();
            };

            const renameSelectedNote = () => {
                const client = findClient(selectedClientId);
                const note = findNote(client, selectedNoteId);
                if (!note) {
                    alert('Select a note to rename.');
                    return;
                }

                const proposedName = noteNameInput.value.trim();
                if (proposedName && proposedName !== note.name) {
                    note.name = proposedName;
                    note.updatedAt = new Date().toISOString();
                    noteNameInput.value = note.name;
                    markDirty();
                    fullRender();
                    return;
                }
                showRenameModal('Rename note', note.name).then(newName => {
                    if (!newName || !newName.trim()) return;
                    note.name = newName.trim();
                    note.updatedAt = new Date().toISOString();
                    noteNameInput.value = note.name;
                    markDirty();
                    fullRender();
                });
            };
            
            clientListEl.addEventListener('click', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (!clientItem) return;

                const clientId = clientItem.dataset.clientId;

                if (e.target.closest('.delete-btn')) {
                     const client = findClient(clientId);
                     if (confirm(`Are you sure you want to delete ${client.name}?`)) {
                        const clientIndex = data.clients.findIndex(c => c.id === clientId);
                        if (clientIndex === -1) return;
                        const [removedClient] = data.clients.splice(clientIndex, 1);
                        if (removedClient.appointments) {
                             deletedItems.appointments.push(...removedClient.appointments.map(a => ({...a, clientId})));
                        }
                        deletedItems.clients.push(removedClient);
                        if (selectedClientId === clientId) {
                            selectedClientId = null;
                            selectedAppointmentId = null;
                            selectedNoteId = null;
                            selectedIntakeId = null;
                        }
                        markDirty();
                        fullRender();
                     }
                } else if (e.target.closest('.archive-btn')) {
                    const clientIndex = data.clients.findIndex(c => c.id === clientId);
                    if (clientIndex === -1) return;
                    const [client] = data.clients.splice(clientIndex, 1);
                    if (!data.archivedClients) data.archivedClients = [];
                    data.archivedClients.push(client);
                    if (selectedClientId === clientId) {
                        selectedClientId = null;
                        selectedAppointmentId = null;
                        selectedNoteId = null;
                        selectedIntakeId = null;
                    }
                    markDirty();
                    fullRender();
                } else if (e.target.closest('.edit-btn')) {
                    const client = findClient(clientId);
                    if (!client) return;
                    showRenameModal(`Rename client`, client.name).then(newName => {
                        if (newName && newName.trim() && newName.trim() !== client.name) {
                            client.name = newName.trim();
                            markDirty();
                            fullRender();
                        }
                    });
                } else {
                    selectClient(clientId);
                }
            });

            // --- Rename Modal Helper ---
            function showRenameModal(title, currentValue) {
                return new Promise((resolve) => {
                    const modal = document.getElementById('renameModal');
                    const input = document.getElementById('renameModalInput');
                    const titleEl = document.getElementById('renameModalTitle');
                    const confirmBtn = document.getElementById('renameModalConfirm');
                    const cancelBtn = document.getElementById('renameModalCancel');
                    
                    titleEl.textContent = title;
                    input.value = currentValue;
                    modal.classList.remove('hidden');
                    setTimeout(() => { input.focus(); input.select(); }, 50);
                    
                    function cleanup() {
                        modal.classList.add('hidden');
                        confirmBtn.removeEventListener('click', onConfirm);
                        cancelBtn.removeEventListener('click', onCancel);
                        input.removeEventListener('keydown', onKeydown);
                    }
                    function onConfirm() { cleanup(); resolve(input.value); }
                    function onCancel() { cleanup(); resolve(null); }
                    function onKeydown(e) {
                        if (e.key === 'Enter') { e.preventDefault(); onConfirm(); }
                        if (e.key === 'Escape') { e.preventDefault(); onCancel(); }
                    }
                    confirmBtn.addEventListener('click', onConfirm);
                    cancelBtn.addEventListener('click', onCancel);
                    input.addEventListener('keydown', onKeydown);
                });
            }

            // --- Drag and Drop Client Reordering (mouse events) ---
            let dragState = null; // { clientId, startY, element, ghost: null, threshold: false }

            function cleanupDrag() {
                if (dragState) {
                    dragState.element.classList.remove('dragging');
                    if (dragState.ghost) {
                        dragState.ghost.remove();
                    }
                }
                document.body.style.cursor = '';
                document.body.classList.remove('dragging-active');
                clientListEl.querySelectorAll('.client-item').forEach(item => {
                    item.classList.remove('drag-over-above', 'drag-over-below');
                });
                dragState = null;
                document.removeEventListener('mousemove', onDragMouseMove);
                document.removeEventListener('mouseup', onDragMouseUp);
            }

            function createDragGhost(sourceEl, x, y) {
                const ghost = sourceEl.cloneNode(true);
                const rect = sourceEl.getBoundingClientRect();
                ghost.className = 'client-item drag-ghost';
                ghost.style.width = rect.width + 'px';
                ghost.style.left = (x - rect.width / 2) + 'px';
                ghost.style.top = (y - rect.height / 2) + 'px';
                ghost.style.background = getComputedStyle(sourceEl).background;
                ghost.style.color = getComputedStyle(sourceEl).color;
                ghost.style.padding = getComputedStyle(sourceEl).padding;
                ghost.style.borderLeft = getComputedStyle(sourceEl).borderLeft;
                // Hide action buttons on ghost
                const btns = ghost.querySelector('.action-buttons');
                if (btns) btns.style.display = 'none';
                document.body.appendChild(ghost);
                return ghost;
            }

            function onDragMouseMove(e) {
                if (!dragState) return;
                const dy = Math.abs(e.clientY - dragState.startY);
                // Require 5px of movement before starting drag (avoids interfering with clicks)
                if (!dragState.threshold) {
                    if (dy < 5) return;
                    dragState.threshold = true;
                    dragState.element.classList.add('dragging');
                    dragState.ghost = createDragGhost(dragState.element, e.clientX, e.clientY);
                    document.body.style.cursor = 'grabbing';
                    document.body.classList.add('dragging-active');
                }
                e.preventDefault(); // prevent text selection while dragging
                // Move ghost
                if (dragState.ghost) {
                    const ghostRect = dragState.ghost.getBoundingClientRect();
                    dragState.ghost.style.left = (e.clientX - ghostRect.width / 2) + 'px';
                    dragState.ghost.style.top = (e.clientY - ghostRect.height / 2) + 'px';
                }
                // Find the item under the cursor
                const items = clientListEl.querySelectorAll('.client-item');
                items.forEach(item => {
                    item.classList.remove('drag-over-above', 'drag-over-below');
                });
                for (const item of items) {
                    if (item.dataset.clientId === dragState.clientId) continue;
                    const rect = item.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;
                    if (e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        if (e.clientY < midY) {
                            item.classList.add('drag-over-above');
                        } else {
                            item.classList.add('drag-over-below');
                        }
                        break;
                    }
                }
            }

            function onDragMouseUp(e) {
                if (!dragState) return;
                const { clientId: sourceId, threshold } = dragState;
                // Clean up visual state
                const items = clientListEl.querySelectorAll('.client-item');
                let targetId = null;
                let insertAfter = false;
                items.forEach(item => {
                    if (item.classList.contains('drag-over-above')) {
                        targetId = item.dataset.clientId;
                        insertAfter = false;
                    } else if (item.classList.contains('drag-over-below')) {
                        targetId = item.dataset.clientId;
                        insertAfter = true;
                    }
                });
                cleanupDrag();

                if (!threshold || !targetId || targetId === sourceId) return;

                const draggedIndex = data.clients.findIndex(c => c.id === sourceId);
                const targetIndex = data.clients.findIndex(c => c.id === targetId);
                if (draggedIndex === -1 || targetIndex === -1) return;

                const [draggedItem] = data.clients.splice(draggedIndex, 1);
                // After removing, recalculate target position
                let newTargetIndex = data.clients.findIndex(c => c.id === targetId);
                if (insertAfter) newTargetIndex += 1;
                data.clients.splice(newTargetIndex, 0, draggedItem);

                markDirty();
                renderClients();
            }

            clientListEl.addEventListener('mousedown', (e) => {
                const clientItem = e.target.closest('.client-item');
                // Don't initiate drag on action buttons
                if (!clientItem || e.target.closest('.action-buttons')) return;
                dragState = {
                    clientId: clientItem.dataset.clientId,
                    startY: e.clientY,
                    element: clientItem,
                    threshold: false,
                    ghost: null
                };
                document.addEventListener('mousemove', onDragMouseMove);
                document.addEventListener('mouseup', onDragMouseUp);
            });

            appointmentListEl.addEventListener('click', (e) => {
                 const appointmentItem = e.target.closest('.appointment-item');
                 const intakeItem = e.target.closest('.intake-item');
                 const noteItem = e.target.closest('.note-item');
                 if (!appointmentItem && !noteItem && !intakeItem) {
                     selectedAppointmentId = null;
                     selectedNoteId = null;
                     selectedIntakeId = null;
                     fullRender();
                     return;
                 }

                 if (intakeItem) {
                    const intakeId = intakeItem.dataset.intakeId;
                    const client = findClient(selectedClientId);
                    if (!client) return;

                    if (e.target.closest('.delete-btn')) {
                        const intakeIndex = (client.intakeSessions || []).findIndex(i => i.id === intakeId);
                        if (intakeIndex > -1 && confirm('Delete this intake session?')) {
                            client.intakeSessions.splice(intakeIndex, 1);
                            if (selectedIntakeId === intakeId) selectedIntakeId = null;
                            markDirty();
                            fullRender();
                        }
                        return;
                    }

                    selectIntakeSession(intakeId);
                    return;
                 }

                 if (noteItem) {
                    const noteId = noteItem.dataset.noteId;
                    const client = findClient(selectedClientId);
                    if (!client) return;

                    if (e.target.closest('.delete-btn')) {
                        const noteIndex = (client.notes || []).findIndex(n => n.id === noteId);
                        if (noteIndex > -1 && confirm('Delete this note?')) {
                            const [removedNote] = client.notes.splice(noteIndex, 1);
                            deletedItems.notes.push({ ...removedNote, clientId: client.id });
                            if (selectedNoteId === noteId) selectedNoteId = null;
                            markDirty();
                            fullRender();
                        }
                        return;
                    }

                    if (e.target.closest('.edit-btn')) {
                        const note = findNote(client, noteId);
                        if (!note) return;
                        showRenameModal('Rename note', note.name).then(newName => {
                            if (newName && newName.trim() && newName.trim() !== note.name) {
                                note.name = newName.trim();
                                note.updatedAt = new Date().toISOString();
                                noteNameInput.value = note.name;
                                markDirty();
                                fullRender();
                            }
                        });
                        return;
                    }

                    selectNote(noteId);
                    const selectedNote = findNote(client, noteId);
                    noteNameInput.value = selectedNote?.name || '';
                    return;
                 }

                 const appointmentId = appointmentItem.dataset.appointmentId;
                 
                 if (e.target.closest('.delete-btn')) {
                    const client = findClient(selectedClientId);
                    if (!client) return;
                    const apptIndex = client.appointments.findIndex(a => a.id === appointmentId);
                    if (apptIndex > -1) {
                        const [appt] = client.appointments.splice(apptIndex, 1);
                        deletedItems.appointments.push({ ...appt, clientId: client.id });
                        if (selectedAppointmentId === appointmentId) {
                            selectedAppointmentId = null;
                        }
                        markDirty();
                        fullRender();
                    }
                 } else {
                     selectAppointment(appointmentId);
                 }
            });
            
            updateAppointmentDateBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                const newDateStr = appointmentDateInput.value;

                if (client && appointment && newDateStr) {
                    const dateObj = new Date(newDateStr);
                    const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());
                    appointment.date = utcDate.toISOString();
                    markDirty();
                    renderAppointments(); // Just re-render appointments to see the change
                    alert('Appointment date updated.');
                } else {
                    alert('Could not update date. Ensure a client, appointment, and date are selected.');
                }
            });

            deletedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const clientIndex = deletedItems.clients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = deletedItems.clients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            archivedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    if (!data.archivedClients) return;
                    const clientIndex = data.archivedClients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = data.archivedClients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            deletedAppointmentsListEl.addEventListener('click', e => {
                 if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const apptIndex = deletedItems.appointments.findIndex(a => a.id === id);
                    if (apptIndex === -1) return;

                    const [appt] = deletedItems.appointments.splice(apptIndex, 1);
                    const client = findClient(appt.clientId);
                    if (client) {
                        if (!client.appointments) client.appointments = [];
                        client.appointments.push(appt);
                        markDirty();
                        fullRender();
                    } else {
                        deletedItems.appointments.push(appt);
                        alert('Cannot restore. Client not found.');
                    }
                 }
            });
            
            clearDeletedClientsBtn.addEventListener('click', () => {
                if(confirm('Permanently delete all recently deleted clients?')) {
                    deletedItems.clients = [];
                    markDirty();
                    fullRender();
                }
            });
            clearDeletedAppointmentsBtn.addEventListener('click', () => {
                 if(confirm('Permanently delete all recently deleted appointments?')) {
                    deletedItems.appointments = [];
                    markDirty();
                    fullRender();
                }
            });
            
            persistentNotesEl.addEventListener('input', () => {
                 const client = findClient(selectedClientId);
                 if (client) {
                     client.persistentNotes = persistentNotesEl.value;
                     markDirty();
                 }
            });

            clientDiagnosisEl.addEventListener('input', () => {
                 const client = findClient(selectedClientId);
                 if (client) {
                     client.diagnosis = clientDiagnosisEl.value;
                     markDirty();
                 }
            });

            const autoResizeTextarea = (el) => {
                // Only resize if the user hasn't manually resized it.
                // We check if the style.height is not set or is 'auto'.
                if (!el.style.height || el.style.height === 'auto') {
                    el.style.height = 'auto';
                    el.style.height = el.scrollHeight + 'px';
                }
            };

            // --- Generic Bullet Point Handlers ---
            const formatBulletPoints = (text) => {
                if (Array.isArray(text)) {
                    text = text.join('\n');
                }
                if (typeof text !== 'string') {
                    text = String(text || '');
                }
                // Split text into individual bullet points and ensure each is on its own line
                let content = text.trim();
                if (!content) return '';
                
                // Replace any bullet points that are not at the start of a line
                content = content.replace(/([^\n])\s*â€¢\s*/g, '$1\nâ€¢ ');
                
                // Split into lines and process each one
                let lines = content.split('\n');
                let newLines = lines.map(line => {
                    let trimmedLine = line.trim();
                    if (trimmedLine.length > 0) {
                        if (!trimmedLine.startsWith('â€¢')) {
                            return 'â€¢ ' + trimmedLine;
                        } else {
                            // Ensure proper spacing after bullet
                            return trimmedLine.replace(/^â€¢\s*/, 'â€¢ ');
                        }
                    }
                    return line; // Keep empty lines as-is
                });
                
                // Filter out consecutive empty lines but keep single empty lines
                let result = [];
                let lastWasEmpty = false;
                for (let line of newLines) {
                    let isEmpty = line.trim().length === 0;
                    if (!isEmpty || !lastWasEmpty) {
                        result.push(line);
                    }
                    lastWasEmpty = isEmpty;
                }
                
                return result.join('\n');
            };

            const handleBulletedInput = (e, saveDataCallback) => {
                const textarea = e.target;

                const shouldAutoResize = textarea.id !== 'sessionInfo';
                if (shouldAutoResize) {
                    textarea.style.height = 'auto';
                }
                
                // If textarea is empty or doesn't start with a bullet, add one
                if (textarea.value.length > 0 && !textarea.value.startsWith('â€¢')) {
                    const cursorPos = textarea.selectionStart;
                    textarea.value = 'â€¢ ' + textarea.value;
                    textarea.selectionStart = textarea.selectionEnd = cursorPos + 2;
                }
                
                if (shouldAutoResize) {
                    autoResizeTextarea(textarea);
                }

                // Save changes using the provided callback
                saveDataCallback(textarea);
            };
            
            const handleBulletedKeyDown = (e) => {
                const textarea = e.target;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;

                if (e.key === 'Enter') {
                    e.preventDefault();
                    
                    const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const currentLine = text.substring(currentLineStart, start);
                    const restOfLine = text.substring(start, text.indexOf('\n', start) === -1 ? text.length : text.indexOf('\n', start));

                    // Check if current line is just bullet with optional spaces
                    const isJustBullet = currentLine.match(/^â€¢\s*$/);
                    
                    // NEW: Check if cursor is right after bullet+space with content following
                    const hasBulletAndSpace = currentLine.match(/^â€¢\s+$/);
                    const hasContentAfter = restOfLine.trim() !== '';

                    if (isJustBullet && !hasContentAfter) {
                        // Empty bullet point line with nothing after - remove it
                        textarea.value = text.substring(0, currentLineStart) + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart;
                    } else if (currentLineStart === 0 && currentLine.trim() === '') {
                        // At very beginning with no content - just add bullet
                        textarea.value = 'â€¢ ' + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = 2;
                    } else if (hasBulletAndSpace && hasContentAfter) {
                        // User is at "â€¢ |content" - insert new bullet above
                        textarea.value = text.substring(0, currentLineStart) + 'â€¢ \n' + text.substring(currentLineStart);
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart + 3;
                    } else {
                        // Normal case - create new line with bullet point
                        textarea.value = text.substring(0, start) + '\nâ€¢ ' + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = start + 3;
                    }
                    
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    return;
                }

                if (e.key === 'Backspace' && start === end) {
                    const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const lineText = text.substring(currentLineStart, start);
                    
                    if (lineText.trim() === 'â€¢' && start > 0) {
                        e.preventDefault();
                        const prevLineEnd = currentLineStart > 0 ? currentLineStart - 1 : 0;
                        textarea.value = text.substring(0, prevLineEnd) + text.substring(start);
                        textarea.selectionStart = textarea.selectionEnd = prevLineEnd;
                        textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }
            };

            // --- Specific Save Callbacks ---
            const saveSessionInfo = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                const note = findNote(client, selectedNoteId);
                if (appointment) {
                    appointment.sessionInfo = textarea.value;
                    delete appointment.auditCheck;
                    markDirty();
                } else if (note) {
                    note.sessionInfo = textarea.value;
                    note.updatedAt = new Date().toISOString();
                    markDirty();
                }
                generateNoteBtn.disabled = !appointment || !hasAppointmentGenerationInput(appointment);
            };

            const saveSoapNote = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    if (!appointment.soap) appointment.soap = {s:'', o:'', a:'', p:''};
                    
                    if (textarea.id === 'interventions') {
                        appointment.soap.interventions = textarea.value;
                    } else {
                        const key = textarea.id.slice(-1).toLowerCase();
                        appointment.soap[key] = textarea.value;
                    }
                    delete appointment.auditCheck;
                    markDirty();
                }
            };

            // --- Attach Bullet Point Handlers ---
            sessionInfoEl.addEventListener('input', (e) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    handleBulletedInput(e, saveSessionInfo);
                } else {
                    saveSessionInfo(e.target);
                }
            });
            sessionInfoEl.addEventListener('keydown', (e) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    handleBulletedKeyDown(e);
                }
            });
            sessionInfoEl.addEventListener('focus', (e) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!appointment) return;
                const textarea = e.target;
                if (textarea.value.length === 0) {
                    textarea.value = 'â€¢ ';
                    textarea.selectionStart = textarea.selectionEnd = 2;
                }
            });

            auditProofSymptomsEl.addEventListener('input', () => saveAuditProofingField('symptoms', auditProofSymptomsEl.value));
            auditProofFunctionalEl.addEventListener('input', () => saveAuditProofingField('functionalImpact', auditProofFunctionalEl.value));
            auditProofProgressEl.addEventListener('input', () => saveAuditProofingField('progressResponse', auditProofProgressEl.value));
            auditProofNecessityEl.addEventListener('input', () => saveAuditProofingField('medicalNecessity', auditProofNecessityEl.value));

            guidingModalitiesListEl.addEventListener('change', (e) => {
                if (!e.target.matches('.modality-select')) return;
                saveGuidingModalities();
            });
            guidingModalitiesListEl.addEventListener('click', (e) => {
                if (e.target.classList.contains('add-modality-btn')) {
                    goalGeneratorModalities.push(DEFAULT_GUIDING_MODALITIES[0]);
                    renderGuidingModalities();
                    return;
                }
                if (e.target.classList.contains('remove-modality-btn')) {
                    if (goalGeneratorModalities.length <= 1) return;
                    const row = e.target.closest('.modality-row');
                    const index = row ? parseInt(row.dataset.modalityIndex, 10) : -1;
                    if (index >= 0) {
                        goalGeneratorModalities.splice(index, 1);
                        if (!goalGeneratorModalities.includes('Other (Specify)')) {
                            goalGeneratorModalityOther = '';
                        }
                        renderGuidingModalities();
                    }
                }
            });
            guidingModalityOtherEl.addEventListener('input', () => {
                goalGeneratorModalityOther = guidingModalityOtherEl.value;
                saveClientGoalGenerationLens();
            });

            intakeFieldsContainerEl.addEventListener('input', (e) => {
                if (!e.target.matches('.intake-field-input')) return;

                const client = findClient(selectedClientId);
                const intakeSession = findIntakeSession(client, selectedIntakeId);
                if (!intakeSession) return;

                if (!intakeSession.fields || typeof intakeSession.fields !== 'object') {
                    intakeSession.fields = {};
                }

                intakeSession.fields[e.target.dataset.intakeKey] = e.target.value;
                markDirty();
            });

            soapContentEl.addEventListener('input', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedInput(e, saveSoapNote);
                }
            });
            soapContentEl.addEventListener('keydown', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedKeyDown(e);
                }
            });
            soapContentEl.addEventListener('focus', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    const textarea = e.target;
                    if (textarea.value.length === 0) {
                        textarea.value = 'â€¢ ';
                        textarea.selectionStart = textarea.selectionEnd = 2;
                    }
                }
            });
            soapContentEl.addEventListener('click', (e) => {
                 if (e.target.id === 'runSoapAuditBtn') {
                     const client = findClient(selectedClientId);
                     const appointment = findAppointment(client, selectedAppointmentId);
                     if (!client || !appointment) {
                        alert('Select an appointment before running an audit check.');
                        return;
                     }
                     appointment.auditCheck = runSoapAuditCheck(client, appointment);
                     markDirty();
                     renderSoap();
                     return;
                 }
                 if (e.target.id === 'selectInterventionsBtn') {
                     const client = findClient(selectedClientId);
                     const appointment = findAppointment(client, selectedAppointmentId);
                     if (!appointment) return;
                     renderInterventionPicker();
                     interventionPickerModal.classList.remove('hidden');
                     return;
                 }
                 if (e.target.classList.contains('copy-btn')) {
                     const targetId = e.target.dataset.target;
                     const textarea = document.getElementById(targetId);
                     if (!textarea) return;
                     navigator.clipboard.writeText(textarea.value).then(() => {
                         const originalText = e.target.textContent;
                         e.target.textContent = 'Copied!';
                         setTimeout(() => { e.target.textContent = originalText; }, 2000);
                     }).catch(err => {
                         console.error('Failed to copy text: ', err);
                         alert('Could not copy text to clipboard.');
                     });
                 }
                 if (e.target.classList.contains('suggestion-accept')) {
                    handleSuggestion(e.target, true);
                 }
                 if (e.target.classList.contains('suggestion-accept-replace')) {
                    handleSuggestion(e.target, true);
                 }
                 if (e.target.classList.contains('suggestion-decline')) {
                    handleSuggestion(e.target, false);
                 }
            });

            const handleSuggestion = (button, isAccepted) => {
                const suggestionBox = button.closest('.suggestion-box');
                const type = suggestionBox.dataset.suggestionType;
                const index = parseInt(suggestionBox.dataset.suggestionIndex, 10);
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);

                if (!appointment || !appointment.soap) return;

                const soapPanelContent = document.getElementById('soapContent');
                const scrollTop = soapPanelContent.scrollTop;

                const suggestionKey = `${type}_suggestion`;
                const suggestionData = appointment.soap[suggestionKey]?.[index];
                if (!suggestionData) return;

                const textarea = document.getElementById(`soap${type.toUpperCase()}`);
                const isReplacement = typeof suggestionData === 'object' && suggestionData.original && suggestionData.suggested;
                let textToAdd = '';

                if (isAccepted) {
                    if (isReplacement) {
                        // User clicked "Use Suggestion"
                        textToAdd = suggestionData.suggested;
                    } else {
                        // User clicked "Accept" for a new suggestion (string)
                        textToAdd = suggestionData;
                    }
                } else { // Declined
                    if (isReplacement) {
                        // User clicked "Keep Original"
                        textToAdd = suggestionData.original;
                    }
                    // If it's a new suggestion (string) and user clicks decline, textToAdd remains empty, which is correct.
                }

                if (textToAdd) {
                    const currentText = textarea.value.trim();
                    // Ensure the text to add is a proper bullet point.
                    const newText = `â€¢ ${textToAdd.replace(/^â€¢\s*/, '')}`;

                    if (currentText.length === 0 || currentText === 'â€¢') {
                        textarea.value = newText;
                    } else {
                        textarea.value = `${currentText}\n${newText}`;
                    }
                    
                    // Manually update the data model since we're not dispatching the 'input' event before re-rendering
                    const key = textarea.id.slice(-1).toLowerCase();
                    appointment.soap[key] = textarea.value;
                }

                // Remove the suggestion that was just handled.
                if (Array.isArray(appointment.soap[suggestionKey])) {
                    appointment.soap[suggestionKey].splice(index, 1);
                }
                
                markDirty();
                renderSoap(); 

                // Restore scroll position
                soapPanelContent.scrollTop = scrollTop;
            };


            const systemPrompt = `You are a helpful assistant for a therapist or clinician. Your primary function is to accurately categorize user-provided session notes into a structured SOAP note format.

**Your Task:**
Analyze the "Session Information" text provided by the user. Categorize every piece of information into one of the four SOAP sections based on the strict definitions below.

- **Subjective (S):** Information reported by the client (e.g., feelings, goals, history). This is for the client's voice and perspective.
  - **CRITICAL:** Each bullet point should be self-sufficient, without relying on other bullet points for context. It should convey a complete thought.
  
- **Objective (O):** Everything that *happens* in the therapy session. This includes all therapeutic interventions, actions taken, connections made, and reflections or psychoeducation provided by the writer. **Any sentence that describes the writer's actions or speech belongs here.** 
  - **CRITICAL:** Each bullet point should be self-sufficient, without relying on other bullet points for context. It should convey a complete thought.
  - **CRITICAL:** Objective content must contain an intervention connected to session content. Do not include observations without corresponding actions or therapeutic moves.
  - **GOLDEN THREAD:** When treatment goals are provided, weave connections between interventions and specific treatment goals/objectives in this section. For example: "Writer provided CBT techniques to address client's anxiety management goal" or "Explored coping strategies related to client's objective of improving emotional regulation." Only make these connections when they are clearly apparent from the session content - don't force connections that aren't naturally there.
    - **REQUIRED WHEN PROVIDED:** If interventions are pre-selected from the Intervention Bank and there is an active objective match, include explicit linkage phrasing such as: "Writer [intervention], addressing treatment plan objective of [objective]."

- **Assessment (A):** The writer's clinical analysis and observations. This includes notes on progress towards goals and direct observations of the client's state (e.g., "client appeared tired," "client's affect was bright"). This section should NOT contain actions or speech from the session.
  - **CRITICAL:** Each bullet point should be self-sufficient, without relying on other bullet points for context. It should convey a complete thought.
  
- **Plan (P):** The course of action for future sessions. This includes topics to be addressed, homework, and any modifications to the treatment plan.
  - **CRITICAL:** Each bullet point should be self-sufficient, without relying on other bullet points for context. It should convey a complete thought.
  
- **Interventions (I):** Identify specific clinical techniques and modalities used during the session. You have more freedom here to interpret the session notes and list the relevant interventions, even if the exact keyword isn't used.
    - **REQUIRED SOURCE CONSTRAINT:** Select interventions ONLY from the provided "Intervention Bank (Allowed Interventions Only)" list.
    - **REQUIRED COMPLETENESS:** Include all applicable interventions from the bank that are supported by the session content.
    - **PROHIBITED:** Do NOT invent, infer, or output interventions that are not explicitly in the Intervention Bank list.
    - If none apply, return: "No interventions selected from the bank."

- **Audit-Proofing Field Mapping (REQUIRED WHEN PROVIDED):**
    - "Symptom Pattern / Severity Context" and "Functional Impact" MUST be integrated into **Subjective (S)**.
    - "Progress / Response to Treatment" and "Medical Necessity Rationale" MUST be integrated into **Assessment (A)**.
    - Preserve these inputs faithfully and do not omit them when present.

**NEW: Suggestions**
- In addition to the main SOAP content, you will provide clinical language suggestions for all four sections when appropriate stronger clinical terminology is available.
- These suggestions should improve clinical precision and professional language without adding new information.
- The suggestions should be returned in four JSON keys: \`s_suggestion\`, \`o_suggestion\`, \`a_suggestion\`, and \`p_suggestion\`.
- For any section (S, O, A, P), the value for its suggestion key (e.g., \`s_suggestion\`) MUST be an array that can contain three types of items:
    1.  A JSON object for suggesting a *revision* to text you've already placed in the corresponding section: \`{"original": "[the exact original text to be replaced]", "suggested": "[the new suggested text]"}\`. The "original" text must be a direct, verbatim quote of one of the bullet points from the corresponding section you generated.
    2.  A simple string for suggesting a *new idea* not already in that section. Example: "Consider exploring coping mechanisms for social anxiety."
    3.  A standalone interpretive insight (no prefix text required) that infers what likely happened in session, assuming interventions when needed and leaning on Narrative/Psychodynamic modalities. These insights do not reference an "original" bullet and should read like complete clinical statements (e.g., "Writer reframed Ct's trauma narrative using Narrative exposure techniques to reinforce agency.").
- A mixed example for an \`a_suggestion\` key would look like: \`[{"original": "â€¢ Ct is tired.", "suggested": "â€¢ Ct presented with fatigue."}, "Recommend weekly check-ins.", "Writer linked Ct's family narrative to psychodynamic themes of loss, highlighting unresolved grief patterns."]\`
- Objective (\`o_suggestion\`) MUST include 7â€“10 interpretive insights of this type. Plan (\`p_suggestion\`) MUST include exactly 3 interpretive insights. Other sections may include or omit these insights as appropriate.
- If you have no suggestion for any section, return an empty array \`[]\` for that key.

**CRITICAL INSTRUCTIONS:**
- **THE GOLDEN RULE:** ONLY use information explicitly provided in the "Session Information" text. Do not use any information from the example output below, which is for formatting reference only.
- **MODALITY LENS HANDLING:** When User Input includes a "Client Modality Lens (Default)" section, use it as a default conceptual lens only. If User Input includes explicit interventions/techniques that indicate a different modality, preserve those interventions as written and do not force them into the default modality lens.
- **INSTRUCTION PRECEDENCE:** When both Persistent Instructions and Session Instructions are provided, Session Instructions override Persistent Instructions for this generated note.
- **PRESERVE SHORTHAND:** Do not expand abbreviations or shorthand. Keep "Ct" as "Ct" (not "Client"), "IBS" as "IBS" (not "Irritable Bowel Syndrome"), etc. Do not add expanded forms in parentheses.
- **CLINICIAN REFERENCE:** Always refer to the clinician as "Writer" (not "the Writer", "the clinician", "therapist", or any other variation).
- **Example of PERFECT Output (FOR FORMATTING ONLY):**
{"s":"â€¢ Ct said they felt bad.","o":"â€¢ Writer talked about coping.","a":"â€¢ Ct displays affect congruent with mood.","p":"â€¢ Continue to explore themes of loss.","i":"â€¢ Psychoeducation\\nâ€¢ Cognitive Restructuring","s_suggestion":[{"original":"â€¢ Ct said they felt bad.","suggested":"â€¢ Ct reported experiencing significant distress."}],"o_suggestion":[{"original":"â€¢ Writer talked about coping.","suggested":"â€¢ Writer provided psychoeducation on coping strategies."}],"a_suggestion":["Client appears to be making progress toward treatment goals related to anxiety."],"p_suggestion":["Continue to utilize CBT techniques to challenge cognitive distortions in the next session."]};
            `;

            const generateSoapNote = async () => {
                if (selectedNoteId || selectedIntakeId) {
                    alert('SOAP note generation is only available for appointments, not Notes or Intake Sessions.');
                    return;
                }
                if (!selectedModel) {
                    alert('Please connect to a provider and select a model in Settings.');
                    return;
                }
                if (apiProvider === 'openwebui') {
                    await generateSoapNoteWithOpenWebUI();
                } else if (apiProvider === 'vertex') {
                    await generateSoapNoteWithVertex();
                } else if (apiProvider === 'openai') {
                    await generateSoapNoteWithOpenAI();
                } else if (apiProvider === 'ollama') {
                    await generateSoapNoteWithOllama();
                } else {
                    alert('Invalid API provider selected.');
                }
            };
            
            const processAndStoreSoapData = (soapData, appointment) => {
                 if (!appointment.soap) appointment.soap = {};
                  delete appointment.auditCheck;
                  const auditProofing = getAuditProofingData(appointment);

                 ['s', 'o', 'a', 'p'].forEach(key => {
                     const suggestionKey = `${key}_suggestion`;
                     const suggestions = soapData[suggestionKey] || [];
                     const fullText = soapData[key] ? formatBulletPoints(soapData[key]) : '';

                     // FIXED: Only add content that's NOT part of suggestions
                     // All suggestion content (both replacements and new additions) should be presented for user approval
                     if (suggestions.length === 0) {
                         // No suggestions - use all the generated content
                         appointment.soap[key] = fullText;
                     } else {
                         // There are suggestions - only include content that's NOT in any suggestions
                         const allSuggestionTexts = suggestions.map(s => {
                             if (typeof s === 'object' && s.original) {
                                 // For replacement suggestions, withhold the original text
                                 return s.original.replace(/^â€¢\s*/, '').trim();
                             } else {
                                 // For new suggestions, withhold the suggestion text itself
                                 return s.replace(/^â€¢\s*/, '').trim();
                             }
                         });

                         // Split the full generated text into bullet points
                         const allBulletPoints = fullText.split('\n').map(line => line.trim()).filter(line => line !== '');

                         // Only include bullet points that are NOT part of any suggestion
                         const immediateTextPoints = allBulletPoints.filter(point => {
                             const trimmedPoint = point.replace(/^â€¢\s*/, '').trim();
                             return !allSuggestionTexts.some(suggestionText => suggestionText === trimmedPoint);
                         });

                         appointment.soap[key] = immediateTextPoints.join('\n');
                     }

                    if (key === 's') {
                        appointment.soap[key] = appendAuditFieldToSection(appointment.soap[key], 'Symptom Pattern / Severity Context', auditProofing.symptoms);
                        appointment.soap[key] = appendAuditFieldToSection(appointment.soap[key], 'Functional Impact', auditProofing.functionalImpact);
                    }
                    if (key === 'a') {
                        appointment.soap[key] = appendAuditFieldToSection(appointment.soap[key], 'Progress / Response to Treatment', auditProofing.progressResponse);
                        appointment.soap[key] = appendAuditFieldToSection(appointment.soap[key], 'Medical Necessity Rationale', auditProofing.medicalNecessity);
                    }
                     
                     // Always store the full list of suggestions for user approval
                     appointment.soap[suggestionKey] = suggestions;
                 });

                 const interventionCorpus = [
                    appointment.sessionInfo || '',
                    soapData?.s || '',
                    soapData?.o || '',
                    soapData?.a || '',
                    soapData?.p || '',
                    soapData?.i || '',
                    appointment.soap.s || '',
                    appointment.soap.o || '',
                    appointment.soap.a || '',
                    appointment.soap.p || '',
                    auditProofing.symptoms || '',
                    auditProofing.functionalImpact || '',
                    auditProofing.progressResponse || '',
                    auditProofing.medicalNecessity || ''
                 ].join('\n');

                 const selectedFromBank = selectInterventionsFromBank(
                    Array.isArray(data.interventionBank) ? data.interventionBank : [],
                    soapData?.i || '',
                    interventionCorpus
                 );

                 appointment.selectedInterventions = selectedFromBank;
                 appointment.soap.interventions = selectedFromBank.length > 0
                    ? selectedFromBank.map(item => `â€¢ ${item}`).join('\n')
                    : 'No interventions selected from the bank.';
             };

            const generateSoapNoteWithOpenAI = async () => {
                if (!selectedModel || !openaiApiKey) {
                    alert('Please connect to OpenAI with an API key and model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !hasAppointmentGenerationInput(appointment)) {
                    alert('Please select a client and appointment, and enter session information and/or audit-proofing details.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const treatmentGoalsContext = getTreatmentGoalsContext(client);
                const selectedObjectivesContext = getSelectedObjectivesContext(client);
                const interventionContext = getInterventionContext(appointment);
                const modalityLensContext = getClientSoapModalityContext(client, appointment);
                const appointmentSessionInfo = appointment.sessionInfo || '';
                const instructionsContext = getInstructionsContext(client, appointment);
                const auditProofing = getAuditProofingData(appointment);
                const auditProofingLines = [
                    auditProofing.symptoms ? `  - Symptom Pattern / Severity Context: ${auditProofing.symptoms}` : null,
                    auditProofing.functionalImpact ? `  - Functional Impact: ${auditProofing.functionalImpact}` : null,
                    auditProofing.progressResponse ? `  - Progress / Response to Treatment: ${auditProofing.progressResponse}` : null,
                    auditProofing.medicalNecessity ? `  - Medical Necessity Rationale: ${auditProofing.medicalNecessity}` : null
                ].filter(Boolean);
                const auditProofingContext = auditProofingLines.length > 0
                    ? `\n- **Audit-Proofing:**\n${auditProofingLines.join('\n')}`
                    : '';

                const userPrompt = `- **Session Information (This Session):**\n${appointmentSessionInfo}${treatmentGoalsContext}${selectedObjectivesContext}${interventionContext}${auditProofingContext}${modalityLensContext}${instructionsContext}`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" }
                };

                try {
                    const response = await tauriFetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiApiKey}`
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`OpenAI API error: ${response.status} - ${errorData.error.message}`);
                    }

                    const result = await response.json();
                    if (!result || !result.choices || !result.choices[0].message.content) {
                        throw new Error("The OpenAI API returned an invalid or empty response.");
                    }

                    let content = result.choices[0].message.content;
                    let soapData = JSON.parse(content);

                    processAndStoreSoapData(soapData, appointment);

                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('OpenAI SOAP Note Generation Error:', error);
                    alert(`Failed to generate SOAP note with OpenAI. Please check your API Key, Model Name, and the console for details.\nError: ${error.message}`);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };

            const generateSoapNoteWithVertex = async () => {
                if (!selectedModel || !vertexServiceAccount || !vertexLocation) {
                    alert('Please connect to Vertex AI with Service Account JSON and location first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !hasAppointmentGenerationInput(appointment)) {
                    alert('Please select a client and appointment, and enter session information and/or audit-proofing details.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const treatmentGoalsContext = getTreatmentGoalsContext(client);
                const selectedObjectivesContext = getSelectedObjectivesContext(client);
                const interventionContext = getInterventionContext(appointment);
                const modalityLensContext = getClientSoapModalityContext(client, appointment);
                const appointmentSessionInfo = appointment.sessionInfo || '';
                const instructionsContext = getInstructionsContext(client, appointment);
                const auditProofing = getAuditProofingData(appointment);
                const auditProofingLines = [
                    auditProofing.symptoms ? `  - Symptom Pattern / Severity Context: ${auditProofing.symptoms}` : null,
                    auditProofing.functionalImpact ? `  - Functional Impact: ${auditProofing.functionalImpact}` : null,
                    auditProofing.progressResponse ? `  - Progress / Response to Treatment: ${auditProofing.progressResponse}` : null,
                    auditProofing.medicalNecessity ? `  - Medical Necessity Rationale: ${auditProofing.medicalNecessity}` : null
                ].filter(Boolean);
                const auditProofingContext = auditProofingLines.length > 0
                    ? `\n- **Audit-Proofing:**\n${auditProofingLines.join('\n')}`
                    : '';

                const userPrompt = `
- **Session Information (This Session):**
${appointmentSessionInfo}${treatmentGoalsContext}${selectedObjectivesContext}${interventionContext}${auditProofingContext}${modalityLensContext}${instructionsContext}
`;
                const fullPrompt = `${systemPrompt}\n\n**User Input:**\n${userPrompt}`;

                const payload = {
                    contents: [{
                        role: "user",
                        parts: [{ text: fullPrompt }]
                    }],
                    generationConfig: {
                        responseMimeType: 'application/json',
                    }
                };

                try {
                    const accessToken = await getGoogleAccessToken(vertexServiceAccount);
                    const credentials = JSON.parse(vertexServiceAccount);
                    const projectId = credentials.project_id;
                    
                    const url = `https://${vertexLocation}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${vertexLocation}/publishers/google/models/${selectedModel}:generateContent`;
                    const response = await tauriFetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${accessToken}`
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`Vertex API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }
                    
                    const result = await response.json();

                    if (!result || !result.candidates || !result.candidates[0]?.content?.parts?.[0]?.text) {
                        throw new Error('The Vertex API returned an invalid or empty response.');
                    }

                    const content = result.candidates[0].content.parts[0].text;
                    const soapData = JSON.parse(content);

                    processAndStoreSoapData(soapData, appointment);

                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('Vertex SOAP Note Generation Error:', error);
                    alert(`Failed to generate SOAP note with Vertex AI. Check your Service Account JSON, location, model, and network connection.\nError: ${error.message}`);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };

            const generateSoapNoteWithOpenWebUI = async () => {
                if (!selectedModel) {
                    alert('Please connect to your server and select a model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !hasAppointmentGenerationInput(appointment)) {
                    alert('Please select a client and appointment, and enter session information and/or audit-proofing details.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const treatmentGoalsContext = getTreatmentGoalsContext(client);
                const selectedObjectivesContext = getSelectedObjectivesContext(client);
                const interventionContext = getInterventionContext(appointment);
                const modalityLensContext = getClientSoapModalityContext(client, appointment);
                const appointmentSessionInfo = appointment.sessionInfo || '';
                const instructionsContext = getInstructionsContext(client, appointment);
                const auditProofing = getAuditProofingData(appointment);
                const auditProofingLines = [
                    auditProofing.symptoms ? `  - Symptom Pattern / Severity Context: ${auditProofing.symptoms}` : null,
                    auditProofing.functionalImpact ? `  - Functional Impact: ${auditProofing.functionalImpact}` : null,
                    auditProofing.progressResponse ? `  - Progress / Response to Treatment: ${auditProofing.progressResponse}` : null,
                    auditProofing.medicalNecessity ? `  - Medical Necessity Rationale: ${auditProofing.medicalNecessity}` : null
                ].filter(Boolean);
                const auditProofingContext = auditProofingLines.length > 0
                    ? `\n- **Audit-Proofing:**\n${auditProofingLines.join('\n')}`
                    : '';

                const userPrompt = `
- **Client Name:** ${client.name}
- **Session Information (This Session):**
${appointmentSessionInfo}${treatmentGoalsContext}${selectedObjectivesContext}${interventionContext}${auditProofingContext}${modalityLensContext}${instructionsContext}`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" },
                    stream: false
                };
                
                try {
                    const headers = new Headers({ 'Content-Type': 'application/json' });
                     if (apiKey) {
                         headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await tauriFetch(`${serverAddress}/api/v1/chat/completions`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload),
                        mode: 'cors'
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    if (!result) {
                        throw new Error("The API returned an empty response. Please check the Open WebUI server logs for errors.");
                    }
                    let content = result.choices[0].message.content;
                    let soapData = {};

                    // Aggressive JSON extraction and cleanup
                    try {
                        // Find the first '{' and the last '}' to extract the JSON part.
                        const firstBrace = content.indexOf('{');
                        const lastBrace = content.lastIndexOf('}');
                        if (firstBrace === -1 || lastBrace === -1 || lastBrace < firstBrace) {
                            throw new Error('AI response did not contain a valid JSON object.');
                        }
                        let jsonString = content.substring(firstBrace, lastBrace + 1);
                        
                        // Attempt to parse it. If it fails, it's likely due to malformed content.
                        try {
                            soapData = JSON.parse(jsonString);
                        } catch (e) {
                            console.warn("Initial JSON.parse failed. Attempting to clean and re-parse.", e.message);
                            // This is a more robust fallback for models that fail to escape content correctly.
                            // It performs multiple passes to clean up common issues.
                            
                            // 1. Remove newlines within JSON strings, which is a common error.
                            let cleanedString = jsonString.replace(/:\s*"(.*?)"/gs, (match, group1) => {
                                const singleLineGroup = group1.replace(/\n/g, '\\n').replace(/\r/g, '');
                                return `: "${singleLineGroup}"`;
                            });

                            // 2. Fix unescaped quotes inside values. This is more complex.
                            // We look for a quote that is not preceded by a backslash.
                            cleanedString = cleanedString.replace(/:\s*"(.*?)"/g, (match, group1) => {
                                const fixedGroup = group1.replace(/(?<!\\)"/g, '\\"');
                                return `: "${fixedGroup}"`;
                            });

                            soapData = JSON.parse(cleanedString); // Retry parsing with the cleaned string
                        }

                    } catch (parseError) {
                        console.error("Failed to parse the following JSON string from the AI:", content);
                        throw new Error(`The AI model returned malformed JSON that could not be automatically fixed. Check the browser console for the raw output. Details: ${parseError.message}`);
                    }
                    
                    processAndStoreSoapData(soapData, appointment);
                    
                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('SOAP Note Generation Error:', error);
                    let alertMessage = `Failed to generate SOAP note. Please check your connection and the console for details.\nError: ${error.message}`;
                    
                    if (error.response?.status === 401) {
                         alertMessage = `Authentication failed (401 Unauthorized) while trying to generate the note. Please re-check your API Key.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch. Check CORS policy on your server.`;
                    }
                    alert(alertMessage);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };

            const generateSoapNoteWithOllama = async () => {
                if (!selectedModel) {
                    alert('Please connect to Ollama and select a model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !hasAppointmentGenerationInput(appointment)) {
                    alert('Please select a client and appointment, and enter session information and/or audit-proofing details.');
                    return;
                }

                const address = (ollamaAddressInput.value || '').trim();
                if (!address) {
                    alert('Please enter your Ollama address in Settings and connect first.');
                    return;
                }
                const base = address.endsWith('/') ? address.slice(0, -1) : address;

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const treatmentGoalsContext = getTreatmentGoalsContext(client);
                const selectedObjectivesContext = getSelectedObjectivesContext(client);
                const interventionContext = getInterventionContext(appointment);
                const modalityLensContext = getClientSoapModalityContext(client, appointment);
                const appointmentSessionInfo = appointment.sessionInfo || '';
                const instructionsContext = getInstructionsContext(client, appointment);
                const auditProofing = getAuditProofingData(appointment);
                const auditProofingLines = [
                    auditProofing.symptoms ? `  - Symptom Pattern / Severity Context: ${auditProofing.symptoms}` : null,
                    auditProofing.functionalImpact ? `  - Functional Impact: ${auditProofing.functionalImpact}` : null,
                    auditProofing.progressResponse ? `  - Progress / Response to Treatment: ${auditProofing.progressResponse}` : null,
                    auditProofing.medicalNecessity ? `  - Medical Necessity Rationale: ${auditProofing.medicalNecessity}` : null
                ].filter(Boolean);
                const auditProofingContext = auditProofingLines.length > 0
                    ? `\n- **Audit-Proofing:**\n${auditProofingLines.join('\n')}`
                    : '';

                const userPrompt = `
- **Client Name:** ${client.name}
- **Session Information (This Session):**
${appointmentSessionInfo}${treatmentGoalsContext}${selectedObjectivesContext}${interventionContext}${auditProofingContext}${modalityLensContext}${instructionsContext}`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userPrompt }
                    ],
                    response_format: { type: 'json_object' },
                    stream: false
                };

                try {
                    const response = await tauriFetch(`${base}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`Ollama API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    if (!result) {
                        throw new Error('The Ollama API returned an empty response. Please check the Ollama server logs for errors.');
                    }
                    let content = result.choices[0].message.content;
                    let soapData = {};

                    try {
                        const firstBrace = content.indexOf('{');
                        const lastBrace = content.lastIndexOf('}');
                        if (firstBrace === -1 || lastBrace === -1 || lastBrace < firstBrace) {
                            throw new Error('AI response did not contain a valid JSON object.');
                        }
                        let jsonString = content.substring(firstBrace, lastBrace + 1);

                        try {
                            soapData = JSON.parse(jsonString);
                        } catch (e) {
                            console.warn('Initial JSON.parse failed for Ollama. Attempting to clean and re-parse.', e.message);
                            let cleanedString = jsonString.replace(/:\s*"(.*?)"/gs, (match, group1) => {
                                const singleLineGroup = group1.replace(/\n/g, '\\n').replace(/\r/g, '');
                                return `: "${singleLineGroup}"`;
                            });
                            cleanedString = cleanedString.replace(/:\s*"(.*?)"/g, (match, group1) => {
                                const fixedGroup = group1.replace(/(?<!\\)"/g, '\\"');
                                return `: "${fixedGroup}"`;
                            });

                            soapData = JSON.parse(cleanedString);
                        }
                    } catch (parseError) {
                        console.error('Failed to parse the following JSON string from Ollama:', content);
                        throw new Error(`The AI model returned malformed JSON that could not be automatically fixed. Check the console for the raw output. Details: ${parseError.message}`);
                    }

                    processAndStoreSoapData(soapData, appointment);
                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('SOAP Note Generation Error (Ollama):', error);
                    let alertMessage = `Failed to generate SOAP note with Ollama. Please check your connection and the console for details.\nError: ${error.message}`;
                    if (error.response?.status === 401) {
                        alertMessage = 'Authentication failed (401 Unauthorized) while trying to generate the note via Ollama.';
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = 'Network Error: Failed to fetch from Ollama. Ensure the Ollama server is running and accessible.';
                    }
                    alert(alertMessage);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };
            
            const connectToServer = async () => {
                apiProvider = apiProviderSelect.value;
                if (apiProvider === 'openwebui') {
                    await connectToOpenWebUI();
                } else if (apiProvider === 'ollama') {
                    await connectToOllama();
                } else if (apiProvider === 'vertex') {
                    await connectToVertex();
                } else if (apiProvider === 'openai') {
                    await connectToOpenAI();
                }
            };
            
            const verifyApiConnection = async () => {
                if (!apiProvider) {
                    alert('Please connect to an API provider first.');
                    return;
                }

                apiStatus.textContent = 'Verifying...';
                apiStatus.style.color = 'orange';

                try {
                    if (apiProvider === 'vertex') {
                        if (!vertexServiceAccount || !vertexLocation || !selectedModel) {
                            throw new Error('Vertex Service Account/location/model not configured.');
                        }
                        
                        const accessToken = await getGoogleAccessToken(vertexServiceAccount);
                        const credentials = JSON.parse(vertexServiceAccount);
                        const projectId = credentials.project_id;
                        
                        const normalizedLocation = (vertexLocation || '').toLowerCase();
                        const vertexHost = normalizedLocation === 'global'
                            ? 'aiplatform.googleapis.com'
                            : `${normalizedLocation}-aiplatform.googleapis.com`;
                        const verifyUrl = `https://${vertexHost}/v1/projects/${projectId}/locations/${normalizedLocation}/publishers/google/models/${selectedModel}:generateContent`;
                        const response = await tauriFetch(verifyUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${accessToken}`
                            },
                            body: JSON.stringify({
                                contents: [{ role: "user", parts: [{ text: 'Reply with OK' }] }],
                                generationConfig: { temperature: 0 }
                            })
                        });
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`API test failed: ${response.status} - ${errorText}`);
                        }
                        apiStatus.textContent = 'Verified âœ“';
                        apiStatus.style.color = 'green';
                    } else if (apiProvider === 'openai') {
                        if (!openaiApiKey || !selectedModel) {
                            throw new Error('OpenAI API key or model not configured.');
                        }
                        const response = await tauriFetch('https://api.openai.com/v1/models/' + selectedModel, {
                            headers: { 'Authorization': `Bearer ${openaiApiKey}` }
                        });
                        if (!response.ok) {
                            throw new Error(`API test failed: ${response.status}`);
                        }
                        apiStatus.textContent = 'Verified âœ“';
                        apiStatus.style.color = 'green';
                    } else if (apiProvider === 'openwebui') {
                        if (!serverAddress) {
                            throw new Error('Server address not configured.');
                        }
                        const response = await tauriFetch(`${serverAddress}/api/models`);
                        if (!response.ok) {
                            throw new Error(`API test failed: ${response.status}`);
                        }
                        apiStatus.textContent = 'Verified âœ“';
                        apiStatus.style.color = 'green';
                    } else if (apiProvider === 'ollama') {
                        const address = (ollamaAddressInput.value || '').trim();
                        if (!address) {
                            throw new Error('Ollama address not configured.');
                        }
                        const base = address.endsWith('/') ? address.slice(0, -1) : address;
                        const response = await tauriFetch(`${base}/v1/models`, { method: 'GET' });
                        if (!response.ok) {
                            throw new Error(`API test failed: ${response.status}`);
                        }
                        apiStatus.textContent = 'Verified âœ“';
                        apiStatus.style.color = 'green';
                    }
                } catch (error) {
                    console.error('API verification error (raw):', error);
                    apiStatus.textContent = 'Verification Failed';
                    apiStatus.style.color = 'red';

                    // Normalize the error into a readable string so we never show "undefined"
                    let message;
                    if (error instanceof Error && error.message) {
                        message = error.message;
                    } else if (typeof error === 'string') {
                        message = error;
                    } else if (error && typeof error.message === 'string') {
                        message = error.message;
                    } else {
                        try {
                            message = JSON.stringify(error);
                        } catch (_) {
                            message = String(error);
                        }
                    }

                    if (
                        apiProvider === 'vertex' &&
                        message &&
                        (message.toLowerCase().includes('load failed') || message.toLowerCase().includes('failed to fetch'))
                    ) {
                        alert(`API verification failed: ${message}\n\nThis usually means the browser could not complete the network request (often CORS/network policy). Try serving this app over http://localhost and verify outbound access to *.googleapis.com.`);
                    } else {
                        alert(`API verification failed: ${message}`);
                    }
                }
            };

            const connectToVertex = async () => {
                const serviceAccount = vertexServiceAccountInput.value.trim();
                const rawLocation = vertexLocationInput.value.trim() || 'us-central1';
                const location = rawLocation.toLowerCase();
                const fallbackModels = [
                    'gemini-2.5-pro',
                    'gemini-2.5-flash',
                    'gemini-2.0-pro-exp-02-05',
                    'gemini-2.0-flash-001',
                    'gemini-2.0-flash-lite-preview-02-05',
                    'gemini-1.5-pro-002',
                    'gemini-1.5-flash-002',
                    'gemini-1.5-flash-8b-001'
                ];

                if (!serviceAccount) {
                    alert('Please provide a Google Cloud Service Account JSON.');
                    return;
                }
                if (!location) {
                    alert('Please provide a Vertex location.');
                    return;
                }

                // Persist normalized (lowercase) location so it stays in sync with API usage.
                vertexLocationInput.value = location;
                vertexLocation = location;

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                vertexModelInput.innerHTML = '<option>Loading models...</option>';
                vertexModelInput.disabled = true;

                try {
                    let models = [...fallbackModels];
                    let modelDiscoveryWarning = null;

                    try {
                        const accessToken = await getGoogleAccessToken(serviceAccount);
                        const credentials = JSON.parse(serviceAccount);
                        const projectId = credentials.project_id;
                        
                        const normalizedLocation = location.toLowerCase();
                        const vertexHost = normalizedLocation === 'global'
                            ? 'aiplatform.googleapis.com'
                            : `${normalizedLocation}-aiplatform.googleapis.com`;
                        const modelsUrl = `https://${vertexHost}/v1/projects/${projectId}/locations/${normalizedLocation}/publishers/google/models`;
                        const response = await tauriFetch(modelsUrl, {
                            method: 'GET',
                            headers: { 'Authorization': `Bearer ${accessToken}` }
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`Failed to fetch models: ${response.status} - ${errorText}`);
                        }

                        const result = await response.json();
                        const apiModels = (result.models || [])
                            .map(m => (m.name || '').split('/').pop())
                            .filter(Boolean)
                            .filter(name => name.toLowerCase().includes('gemini'));

                        if (apiModels.length > 0) {
                            models = [...new Set([...apiModels, ...fallbackModels])];
                        }
                    } catch (discoveryError) {
                        console.warn('Vertex model discovery failed; using fallback model list.', discoveryError);
                        // We don't need to show a warning to the user if fallback models are loaded successfully.
                        // The user can still select a model and verify the connection.
                    }

                    vertexModelInput.innerHTML = '';
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        vertexModelInput.appendChild(option);
                    });

                    vertexServiceAccount = serviceAccount;
                    vertexLocation = location;

                    const savedModel = localStorage.getItem('vertexModel');
                    if (savedModel && models.includes(savedModel)) {
                        vertexModelInput.value = savedModel;
                    } else if (models.includes('gemini-2.5-flash')) {
                        vertexModelInput.value = 'gemini-2.5-flash';
                    } else if (models.includes('gemini-2.0-flash-001')) {
                        vertexModelInput.value = 'gemini-2.0-flash-001';
                    } else {
                        vertexModelInput.value = models[0];
                    }

                    selectedModel = vertexModelInput.value;
                    vertexModelInput.disabled = false;

                    localStorage.setItem('apiProvider', 'vertex');
                    localStorage.setItem('vertexServiceAccount', vertexServiceAccount);
                    localStorage.setItem('vertexLocation', vertexLocation);
                    localStorage.setItem('vertexModel', selectedModel);

                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    verifyApiBtn.classList.remove('hidden');

                } catch (error) {
                    console.error('Vertex connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    vertexModelInput.innerHTML = '<option>Connection Failed</option>';
                    vertexServiceAccount = null;
                    vertexLocation = 'us-central1';
                    selectedModel = null;
                    alert(`Failed to connect to Vertex AI. Check your Service Account JSON, location, and network connection.\nError: ${error.message}`);
                } finally {
                    fullRender();
                }
            };
            
            const connectToOpenAI = async () => {
                const key = openaiApiKeyInput.value.trim();
                if (!key) {
                    alert('Please provide an OpenAI API Key.');
                    return;
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                openaiModelInput.innerHTML = '<option>Loading models...</option>';
                openaiModelInput.disabled = true;

                try {
                    const response = await tauriFetch('https://api.openai.com/v1/models', {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${key}`
                        }
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Failed to fetch models: ${response.status} - ${errorData.error.message}`);
                    }
                    const data = await response.json();

                    const models = data.data
                        .filter(m => m.id.includes('gpt') && m.id.includes('instruct') === false) // Filter for chat models
                        .sort((a, b) => a.id.localeCompare(b.id)) // Sort them
                        .map(m => m.id);

                    if (models.length === 0) {
                        throw new Error("No compatible GPT models found.");
                    }

                    openaiModelInput.innerHTML = '';
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        openaiModelInput.appendChild(option);
                    });

                    openaiApiKey = key;
                    
                    const savedModel = localStorage.getItem('openaiModel');
                    if (savedModel && models.includes(savedModel)) {
                        openaiModelInput.value = savedModel;
                    } else if (models.includes('gpt-4o')) { // Prefer gpt-4o
                        openaiModelInput.value = 'gpt-4o';
                    } else if (models.includes('gpt-3.5-turbo')) {
                        openaiModelInput.value = 'gpt-3.5-turbo';
                    } else {
                        openaiModelInput.value = models[0]; // Fallback
                    }
                    
                    selectedModel = openaiModelInput.value;
                    openaiModelInput.disabled = false;

                    localStorage.setItem('apiProvider', 'openai');
                    localStorage.setItem('openaiApiKey', openaiApiKey);
                    localStorage.setItem('openaiModel', selectedModel);

                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    verifyApiBtn.classList.remove('hidden');

                } catch (error) {
                    console.error('OpenAI connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    openaiModelInput.innerHTML = '<option>Connection Failed</option>';
                    openaiApiKey = null;
                    selectedModel = null;
                    alert(`Failed to connect to OpenAI. Check your API key and network connection.\nError: ${error.message}`);
                } finally {
                    fullRender();
                }
            };

            const connectToOpenWebUI = async () => {
                const address = serverAddressInput.value.trim();
                if (!address) {
                    alert('Please enter an Open WebUI address.');
                    return;
                }
                serverAddress = address.endsWith('/') ? address.slice(0, -1) : address;
                apiKey = apiKeyInput.value.trim();

                // Save settings to local storage immediately
                localStorage.setItem('apiProvider', 'openwebui');
                localStorage.setItem('serverAddress', serverAddress);
                if (apiKey) {
                    localStorage.setItem('apiKey', apiKey);
                } else {
                    localStorage.removeItem('apiKey');
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                modelSelect.innerHTML = '<option>Loading models...</option>';
                modelSelect.disabled = true;

                try {
                    const headers = new Headers();
                    if (apiKey) {
                        headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await tauriFetch(`${serverAddress}/api/v1/models`, { headers, mode: 'cors' });
                    if (!response.ok) {
                        const error = new Error(`Failed to connect to Open WebUI. Status: ${response.status}`);
                        error.response = response;
                        throw error;
                    }
                    const data = await response.json();
                    
                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    
                    // localStorage.setItem('serverAddress', serverAddress);
                    // if (apiKey) localStorage.setItem('apiKey', apiKey);
                    // else localStorage.removeItem('apiKey');
                    
                    modelSelect.innerHTML = '';
                    const models = data.data;

                    if (models && models.length > 0) {
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                                                         option.textContent = model.id;
                            modelSelect.appendChild(option);
                        });

                        let autoSelectedModelId = null;
                        const llamaModel = models.find(m => m.id === 'llama3.2:3b');
                        const deepseekModel = models.find(m => m.id === 'deepseek-r1:1.5b');

                        if (llamaModel) {
                            autoSelectedModelId = llamaModel.id;
                        } else if (deepseekModel) {
                            autoSelectedModelId = deepseekModel.id;
                        } else {
                            const fallbackModel = models.find(m => 
                                m.id !== 'arena-model' && 
                                !m.id.toLowerCase().includes('coder') && 
                                !m.id.toLowerCase().includes('coding')
                            );
                            if (fallbackModel) {
                                autoSelectedModelId = fallbackModel.id;
                            }
                        }

                        if (autoSelectedModelId) {
                            modelSelect.value = autoSelectedModelId;
                        } else if (models.length > 0) {
                            modelSelect.value = models[0].id;
                        }

                        selectedModel = modelSelect.value;
                        modelSelect.disabled = false;
                        
                    } else {

                        modelSelect.innerHTML = '<option>No models found</option>';
                        selectedModel = null;
                        modelSelect.disabled = true;
                    }

                } catch (error) {
                    console.error('API connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    serverAddress = null;
                    modelSelect.innerHTML = '<option>Connection failed</option>';
                    
                                        
                    let alertMessage = `Connection to "${address}" failed.`;
                    
                    if (error.response?.status === 401) {
                         alertMessage += `\n\nError: Authentication failed (401 Unauthorized). Please check if your API Key is correct and has the necessary permissions. Some servers require an API key even if it's optional in the UI.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch.

This is the most common error and is almost always caused by one of two things:

1.  **CORS Policy:** Your browser is blocking the request for security reasons. The Open WebUI server must be configured to allow requests from this webpage.
    *SOLUTION:* In your Open WebUI settings, find the "Allowed Origins" configuration and add the URL of this page. You can often just add "*" to allow all origins, but this is less secure.

2.  **Server Not Reachable:** The address "${address}" is incorrect, or the Open WebUI server is not running. Please double-check the address and ensure the server is active.

This error cannot be fixed within this application's code; it requires a configuration change on the server you are trying to connect to.`;
                    } else {
                         alertMessage += `\n\nError: ${error.message}`;
                    }
                    alert(alertMessage);

                } finally {
                    fullRender();
                }
            };

            const connectToOllama = async () => {
                const address = (ollamaAddressInput.value || '').trim();
                if (!address) {
                    alert('Please enter an Ollama address.');
                    return;
                }

                const base = address.endsWith('/') ? address.slice(0, -1) : address;
                ollamaAddress = base;

                // Save settings to local storage
                localStorage.setItem('apiProvider', 'ollama');
                localStorage.setItem('ollamaAddress', ollamaAddress);

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                modelSelect.innerHTML = '<option>Loading models...</option>';
                modelSelect.disabled = true;

                try {
                    const response = await tauriFetch(`${ollamaAddress}/v1/models`, { method: 'GET' });
                    if (!response.ok) {
                        const error = new Error(`Failed to connect to Ollama. Status: ${response.status}`);
                        error.response = response;
                        throw error;
                    }

                    const data = await response.json();
                    const rawModels = Array.isArray(data?.data) ? data.data : (Array.isArray(data?.models) ? data.models : (Array.isArray(data) ? data : []));

                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';

                    modelSelect.innerHTML = '';

                    if (rawModels && rawModels.length > 0) {
                        rawModels.forEach(model => {
                            const id = model.id || model.name || model.model;
                            if (!id) return;
                            const option = document.createElement('option');
                            option.value = id;
                            option.textContent = id;
                            modelSelect.appendChild(option);
                        });

                        const savedOllamaModel = localStorage.getItem('ollamaModel');
                        if (savedOllamaModel && Array.from(modelSelect.options).some(opt => opt.value === savedOllamaModel)) {
                            modelSelect.value = savedOllamaModel;
                        } else if (rawModels.length > 0) {
                            modelSelect.value = rawModels[0].id || rawModels[0].name || rawModels[0].model;
                        }

                        selectedModel = modelSelect.value;
                        modelSelect.disabled = false;
                    } else {
                        modelSelect.innerHTML = '<option>No models found</option>';
                        selectedModel = null;
                        modelSelect.disabled = true;
                    }
                } catch (error) {
                    console.error('Ollama connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    ollamaAddress = null;
                    modelSelect.innerHTML = '<option>Connection failed</option>';
                    // Normalize error into a readable message so we never show "undefined"
                    let message;
                    if (error instanceof Error && error.message) {
                        message = error.message;
                    } else if (typeof error === 'string') {
                        message = error;
                    } else if (error && typeof error.message === 'string') {
                        message = error.message;
                    } else {
                        try {
                            message = JSON.stringify(error);
                        } catch (_) {
                            message = String(error);
                        }
                    }

                    let alertMessage = `Connection to "${address}" failed.`;
                    if (error?.response?.status === 401) {
                        alertMessage += '\n\nError: Authentication failed (401 Unauthorized). Please check your Ollama configuration.';
                    } else if (message && message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch.\n\nThis usually means the runtime could not reach \"${address}\".\n\nPlease check:\n- That the Ollama server is running and listening on this address/port.\n- That the Tauri HTTP plugin allowlist (in src-tauri/tauri.conf.json) includes this host/port.\n- Any local firewall or VPN that might be blocking localhost connections.`;
                    } else {
                        alertMessage += `\n\nError: ${message}`;
                    }
                    alert(alertMessage);
                } finally {
                    fullRender();
                }
            };


            // --- Data Persistence (Save/Load/AutoSave) ---
            const updateSaveStatus = (message, isGood = true, duration = 0) => {
                autoSaveIndicator.style.opacity = '1';
                saveStatus.textContent = message;
                saveStatus.style.color = isGood ? 'white' : '#f1c40f'; // Gold for warning
                if (duration > 0) {
                    setTimeout(() => {
                        if (saveStatus.textContent === message) {
                            autoSaveIndicator.style.opacity = '0';
                        }
                    }, duration);
                }
            }

            const markDirty = () => {
                if (!isDirty) {
                    isDirty = true;
                    updateSaveStatus('Unsaved changes...', false);
                }
                debouncedAutoSave();
            };

            const saveDataToLocalStorage = async () => {
                try {
                    const state = { data, deletedItems, selectedClientId, selectedAppointmentId, selectedNoteId, selectedIntakeId };
                    
                    if (isDatabaseInitialized()) {
                        const success = await saveState(state);
                        if (!success) throw new Error("Database save failed");
                    } else {
                        // Fallback to localStorage if DB not ready
                        const dataStr = JSON.stringify(state);
                        localStorage.setItem('clientData', dataStr);
                    }
                    
                    isDirty = false;
                    await persistEncryptedAutoBackup();
                } catch (e) {
                    console.error("Failed to save data", e);
                    updateSaveStatus('Save failed!', false, 3000);
                    // Handle potential quota exceeded error
                    if (e.name === 'QuotaExceededError') {
                        alert('Failed to save data: Storage quota exceeded. Please export your data to a file and consider clearing some old records.');
                    }
                }
            };

            const loadDataFromLocalStorage = async () => {
                try {
                    let state = null;
                    
                    if (isDatabaseInitialized()) {
                        state = await loadState();
                    }
                    
                    // Fallback to localStorage if DB is empty or not initialized
                    if (!state) {
                        const dataStr = localStorage.getItem('clientData');
                        if (dataStr) {
                            state = JSON.parse(dataStr);
                        }
                    }

                    if (state) {
                        data = state.data || getInitialData();
                        if (!data.archivedClients) data.archivedClients = [];
                        deletedItems = state.deletedItems || { clients: [], appointments: [], notes: [] };
                        selectedClientId = null;
                        selectedAppointmentId = null;
                        selectedNoteId = null;
                        selectedIntakeId = null;
                        normalizeClientData();

                        // Load API settings
                        const savedProvider = localStorage.getItem('apiProvider');
                        if (savedProvider) {
                            apiProvider = savedProvider;
                            apiProviderSelect.value = apiProvider;
                            toggleProviderSettings();
                        }
                        serverAddressInput.value = localStorage.getItem('serverAddress') || '';
                        apiKeyInput.value = localStorage.getItem('apiKey') || '';
                        if (ollamaAddressInput) {
                            ollamaAddressInput.value = localStorage.getItem('ollamaAddress') || '';
                        }
                        vertexServiceAccountInput.value = localStorage.getItem('vertexServiceAccount') || '';
                        if (vertexServiceAccountInput.value) {
                            vertexKeyStatus.textContent = 'Key loaded from storage';
                            vertexKeyStatus.style.color = '#27ae60';
                            clearVertexKeyBtn.classList.remove('hidden');
                        }
                        vertexLocationInput.value = localStorage.getItem('vertexLocation') || 'us-central1';
                        openaiApiKeyInput.value = localStorage.getItem('openaiApiKey') || '';
                    }
                } catch (e) {
                    console.error("Failed to load data", e);
                    alert("Error loading data. Data might be corrupt or password incorrect. Starting fresh.");
                    data = getInitialData();
                    deletedItems = { clients: [], appointments: [], notes: [] };
                }
            };

            const exportFile = async () => {
                try {
                    const isTauriRuntime = typeof window !== 'undefined' && !!window.__TAURI_INTERNALS__;
                    if (isTauriRuntime) {
                        if (!isDatabaseInitialized()) {
                            throw new Error('Encrypted SQL export requires an active authenticated desktop session.');
                        }

                        await saveDataToLocalStorage();
                        const encryptedSqlPayload = await exportEncryptedSqlDump();
                        exportDataText.value = JSON.stringify(encryptedSqlPayload, null, 2);
                        exportDataModal.classList.remove('hidden');
                        updateSaveStatus('Encrypted SQL export ready.', true, 2500);
                        return;
                    }

                    const stateToSave = { data, deletedItems, selectedClientId, selectedAppointmentId, selectedNoteId, selectedIntakeId };
                    const stateJSON = JSON.stringify(stateToSave, null, 2);
                    const blob = new Blob([stateJSON], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `client-data-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    updateSaveStatus('Exported.', true, 2000);
                } catch (err) {
                    console.error('Failed to export file:', err);
                    alert(`Export failed!\n\nError: ${err.message}`);
                    updateSaveStatus('Export failed!', false, 3000);
                }
            };

            let saveTimeout;
            const debouncedAutoSave = () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    saveDataToLocalStorage();
                    updateSaveStatus('Auto-saved', true, 2000);
                }, 1500);
            };

            const loadFile = () => {
                 if (isDirty && !confirm('You have unsaved changes that will be lost. Are you sure you want to import a new file?')) {
                     return;
                 }
                fileInput.click();
            };

            const applyImportedState = (state) => {
                data = state.data || getInitialData();
                deletedItems = state.deletedItems || { clients: [], appointments: [], notes: [] };
                selectedClientId = state.selectedClientId || null;
                selectedAppointmentId = state.selectedAppointmentId || null;
                selectedNoteId = state.selectedNoteId || null;
                selectedIntakeId = state.selectedIntakeId || null;

                if (!data.archivedClients) {
                    data.archivedClients = [];
                }

                normalizeClientData();
                isDirty = false;
                fullRender();
            };

            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const contents = await file.text();
                    const fileName = (file.name || '').toLowerCase();
                    const trimmed = (contents || '').trim();

                    if (fileName.endsWith('.sql')) {
                        if (!isDatabaseInitialized()) {
                            throw new Error('SQL import requires an active authenticated desktop session.');
                        }

                        await importSqlDump(contents);
                        const restoredState = await loadState();
                        if (!restoredState) {
                            throw new Error('SQL import completed, but no application state could be loaded.');
                        }

                        applyImportedState(restoredState);
                        alert(`Imported SQL backup ${file.name} successfully.`);
                        updateSaveStatus('SQL import completed.', true, 2500);
                        return;
                    }

                    let parsed;
                    try {
                        parsed = JSON.parse(contents);
                    } catch (_jsonError) {
                        if (trimmed.includes('CREATE TABLE') || trimmed.includes('INSERT INTO')) {
                            if (!isDatabaseInitialized()) {
                                throw new Error('SQL import requires an active authenticated desktop session.');
                            }

                            await importSqlDump(contents);
                            const restoredState = await loadState();
                            if (!restoredState) {
                                throw new Error('SQL import completed, but no application state could be loaded.');
                            }

                            applyImportedState(restoredState);
                            alert(`Imported SQL backup ${file.name} successfully.`);
                            updateSaveStatus('SQL import completed.', true, 2500);
                            return;
                        }
                        throw new Error('File is neither valid JSON state nor SQL dump.');
                    }

                    if (parsed && parsed.format === 'client-records-sql-export' && typeof parsed.data === 'string') {
                        if (!isDatabaseInitialized()) {
                            throw new Error('Encrypted SQL import requires an active authenticated desktop session.');
                        }

                        await importEncryptedSqlDump(parsed);
                        const restoredState = await loadState();
                        if (!restoredState) {
                            throw new Error('Encrypted SQL import completed, but state could not be loaded.');
                        }

                        applyImportedState(restoredState);
                        alert(`Imported encrypted SQL backup ${file.name} successfully.`);
                        updateSaveStatus('Encrypted SQL import completed.', true, 2500);
                        return;
                    }

                    if (!parsed || !parsed.data || !parsed.deletedItems) {
                        throw new Error('Invalid JSON file structure. Required properties are missing.');
                    }

                    applyImportedState(parsed);
                    await saveDataToLocalStorage();
                    alert(`Imported JSON backup ${file.name} successfully.`);
                    updateSaveStatus('JSON import completed.', true, 2500);
                } catch (err) {
                    console.error('Failed to load file:', err);
                    alert(`Import failed!\n\nError: ${err.message}`);
                    updateSaveStatus('Import failed.', false, 3000);
                } finally {
                    fileInput.value = '';
                }
            });

            const eraseAllData = () => {
                const confirmationText = "DELETE ALL DATA";
                const userInput = prompt(`This action will permanently erase all client data from this browser. This cannot be undone.\n\nTo confirm, please type "${confirmationText}" in the box below.`);
                if (userInput === confirmationText) {
                    data = getInitialData();
                    deletedItems = { clients: [], appointments: [], notes: [] };
                    selectedClientId = null;
                    selectedAppointmentId = null;
                    selectedNoteId = null;
                    selectedIntakeId = null;
                    isDirty = false;
                    localStorage.removeItem('clientData');
                    localStorage.removeItem('serverAddress');
                    localStorage.removeItem('apiKey');
                    localStorage.removeItem('vertexServiceAccount');
                    localStorage.removeItem('vertexLocation');
                    localStorage.removeItem('openaiApiKey');
                    localStorage.removeItem('vertexModel');
                    localStorage.removeItem('openaiModel');
                    localStorage.removeItem('apiProvider');
                    localStorage.removeItem('columnSizes');
                    localStorage.removeItem('rowSizes');
                    localStorage.removeItem('theme');
                    alert('All data has been permanently erased. The page will now reload.');
                    window.location.reload();
                } else if (userInput !== null) {
                    alert('The text you entered did not match. No data has been erased.');
                }
            };

            const resolveErrorMessage = (error) => {
                if (error instanceof Error && error.message) {
                    return error.message;
                }
                if (typeof error === 'string') {
                    return error;
                }
                try {
                    return JSON.stringify(error);
                } catch (_stringifyError) {
                    return String(error);
                }
            };

            const normalizeSelectedPath = (selectedPath) => {
                if (typeof selectedPath !== 'string') return '';
                if (selectedPath.startsWith('file://')) {
                    try {
                        return decodeURIComponent(new URL(selectedPath).pathname);
                    } catch (_urlError) {
                        return selectedPath;
                    }
                }
                return selectedPath;
            };

            const isTauriRuntime = () => typeof window !== 'undefined' && !!window.__TAURI_INTERNALS__;

            const updateBackupMenuState = () => {
                if (configureBackupBtn) {
                    configureBackupBtn.textContent = autoBackupPath
                        ? `Update Secondary Backup Location (${autoBackupPath.split('/').pop() || 'configured'})`
                        : 'Set Secondary Backup Location';
                }
                if (clearBackupBtn) {
                    clearBackupBtn.disabled = !autoBackupPath;
                    clearBackupBtn.style.opacity = autoBackupPath ? '1' : '0.6';
                    clearBackupBtn.style.cursor = autoBackupPath ? 'pointer' : 'not-allowed';
                }
            };

            const persistEncryptedAutoBackup = async () => {
                if (!autoBackupPath || !isTauriRuntime() || !isDatabaseInitialized()) return;

                if (backupWriteInProgress) {
                    backupWritePending = true;
                    return;
                }

                backupWriteInProgress = true;
                try {
                    const encryptedSqlPayload = await exportEncryptedSqlDump();
                    await writeTextFile(autoBackupPath, JSON.stringify(encryptedSqlPayload, null, 2), { create: true });
                } catch (error) {
                    console.error('Secondary auto-backup write failed:', error);
                    updateSaveStatus(`Secondary backup failed: ${resolveErrorMessage(error)}`, false, 4000);
                } finally {
                    backupWriteInProgress = false;
                    if (backupWritePending) {
                        backupWritePending = false;
                        setTimeout(() => {
                            persistEncryptedAutoBackup();
                        }, 0);
                    }
                }
            };

            const configureSecondaryBackupLocation = async () => {
                if (!isTauriRuntime()) {
                    alert('Secondary auto-backup location selection is available in the desktop app runtime.');
                    return;
                }

                if (!isDatabaseInitialized()) {
                    alert('Please log in first so encrypted backup can be initialized.');
                    return;
                }

                try {
                    const defaultFileName = `client-data-autobackup-${new Date().toISOString().split('T')[0]}.sql.enc.json`;
                    const selectedPath = await save({
                        title: 'Choose Secondary Auto-Backup Destination',
                        defaultPath: autoBackupPath || localStorage.getItem('autoBackupPath') || defaultFileName,
                        filters: [
                            {
                                name: 'Encrypted SQL Backup',
                                extensions: ['json']
                            }
                        ]
                    });

                    if (!selectedPath) return;

                    const normalizedPath = normalizeSelectedPath(selectedPath);
                    if (!normalizedPath) {
                        throw new Error('No valid backup path returned by dialog.');
                    }

                    autoBackupPath = normalizedPath;
                    localStorage.setItem('autoBackupPath', autoBackupPath);
                    updateBackupMenuState();
                    await persistEncryptedAutoBackup();
                    updateSaveStatus('Secondary auto-backup location configured.', true, 3000);
                } catch (error) {
                    console.error('Failed to configure secondary backup path:', error);
                    alert(`Failed to configure secondary backup location.\n\nError: ${resolveErrorMessage(error)}`);
                    updateSaveStatus('Secondary backup configuration failed.', false, 3000);
                }
            };

            const clearSecondaryBackupLocation = () => {
                autoBackupPath = '';
                localStorage.removeItem('autoBackupPath');
                updateBackupMenuState();
                updateSaveStatus('Secondary auto-backup cleared.', true, 2500);
            };

            const downloadExportData = async () => {
                const json = exportDataText.value || '';
                if (!json) return;

                const defaultFileName = `client-data-${new Date().toISOString().split('T')[0]}.sql.enc.json`;
                const isTauriRuntime = typeof window !== 'undefined' && !!window.__TAURI_INTERNALS__;

                if (isTauriRuntime) {
                    try {
                        const lastExportPath = localStorage.getItem('lastExportPath') || defaultFileName;
                        const selectedPath = await save({
                            title: 'Save Encrypted SQL Export',
                            defaultPath: lastExportPath,
                            filters: [
                                {
                                    name: 'Encrypted SQL Export',
                                    extensions: ['json']
                                }
                            ]
                        });

                        if (!selectedPath) {
                        autoBackupPath = localStorage.getItem('autoBackupPath') || '';
                        updateBackupMenuState();
                            return;
                        }

                        const normalizedPath = normalizeSelectedPath(selectedPath);
                        if (!normalizedPath) {
                            throw new Error('No valid save path returned by dialog.');
                        }

                        await writeTextFile(normalizedPath, json, { create: true });
                        localStorage.setItem('lastExportPath', normalizedPath);
                        updateSaveStatus('Encrypted export saved.', true, 2500);
                        exportDataModal.classList.add('hidden');
                        return;
                    } catch (error) {
                        console.error('Failed to save encrypted export with native dialog:', error);
                        alert(`Save failed!\n\nError: ${resolveErrorMessage(error)}`);
                        updateSaveStatus('Save failed.', false, 3000);
                        return;
                    }
                }

                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const customName = prompt('Choose export filename', defaultFileName);
                if (customName === null) {
                    URL.revokeObjectURL(url);
                    return;
                }

                let normalizedName = customName.trim() || defaultFileName;
                if (!normalizedName.endsWith('.json')) {
                    normalizedName += '.json';
                }

                a.download = normalizedName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // --- Event Listeners ---
            addClientBtn.addEventListener('click', openAddClientModal);
            closeAddClientBtn.addEventListener('click', closeAddClientModal);
            cancelAddClientBtn.addEventListener('click', closeAddClientModal);
            confirmAddClientBtn.addEventListener('click', addClient);
            addClientNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addClient();
                }
            });
            addClientModal.addEventListener('click', (e) => {
                if (e.target.id === 'addClientModal') {
                    closeAddClientModal();
                }
            });
            sortClientsBtn.addEventListener('click', () => {
                data.clients.sort((a, b) => a.name.localeCompare(b.name));
                markDirty();
                renderClients();
            });
            addAppointmentBtn.addEventListener('click', addAppointment);
            addIntakeBtn.addEventListener('click', addIntakeSession);
            addNoteBtn.addEventListener('click', addNote);
            renameNoteBtn.addEventListener('click', renameSelectedNote);
            noteNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedNoteId) {
                        renameSelectedNote();
                    } else {
                        addNote();
                    }
                }
            });
            addGoalBtnInTab.addEventListener('click', addGoal);

            // Tab switching functionality
            appointmentsTabBtn.addEventListener('click', () => {
                appointmentsTabBtn.style.color = 'var(--text-color-primary)';
                appointmentsTabBtn.style.borderBottomColor = '#3498db';
                goalsTabBtn.style.color = 'var(--text-color-secondary)';
                goalsTabBtn.style.borderBottomColor = 'transparent';
                appointmentsTabContent.style.display = 'flex';
                goalsTabContent.style.display = 'none';
            });

            goalsTabBtn.addEventListener('click', () => {
                goalsTabBtn.style.color = 'var(--text-color-primary)';
                goalsTabBtn.style.borderBottomColor = '#3498db';
                appointmentsTabBtn.style.color = 'var(--text-color-secondary)';
                appointmentsTabBtn.style.borderBottomColor = 'transparent';
                goalsTabContent.style.display = 'flex';
                appointmentsTabContent.style.display = 'none';
            });

            // Goals event delegation
            goalsListInTabEl.addEventListener('click', (e) => {
                const goalItem = e.target.closest('.goal-item');
                if (!goalItem) return;
                
                const goalId = goalItem.dataset.goalId;
                
                if (e.target.classList.contains('add-objective-btn')) {
                    addObjective(goalId);
                } else if (e.target.classList.contains('objective-checkbox')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    toggleObjective(goalId, objectiveId);
                } else if (e.target.classList.contains('edit-objective-btn')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    editObjective(goalId, objectiveId);
                } else if (e.target.classList.contains('timeline-objective-btn')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    editObjectiveTimeline(goalId, objectiveId);
                } else if (e.target.closest('.objective-item') && e.target.classList.contains('delete-btn')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    deleteObjective(goalId, objectiveId);
                } else if (e.target.classList.contains('edit-btn')) {
                    editGoal(goalId);
                } else if (e.target.classList.contains('timeline-btn')) {
                    editGoalTimeline(goalId);
                } else if (e.target.classList.contains('archive-btn')) {
                    changeGoalStatus(goalId);
                } else if (e.target.classList.contains('delete-btn')) {
                    deleteGoal(goalId);
                }
            });

            // Show/hide objective delete buttons on hover
            goalsListInTabEl.addEventListener('mouseover', (e) => {
                const objectiveItem = e.target.closest('.objective-item');
                if (objectiveItem) {
                    objectiveItem.querySelectorAll('.action-btn').forEach(btn => {
                        btn.style.opacity = '1';
                    });
                }
            });

            goalsListInTabEl.addEventListener('mouseout', (e) => {
                const objectiveItem = e.target.closest('.objective-item');
                if (objectiveItem) {
                    objectiveItem.querySelectorAll('.action-btn').forEach(btn => {
                        btn.style.opacity = '0';
                    });
                }
            });

            generateGoalsBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                generatedGoalsDraft = [];
                const clientLens = getClientGoalGenerationLens(client);
                goalGeneratorModalities = [...clientLens.modalities];
                goalGeneratorModalityOther = clientLens.other || '';
                goalProblemInput.value = '';
                goalCountInput.value = '2';
                objectiveCountInput.value = '4';
                objectiveStyleSelect.value = 'action';
                renderGuidingModalities();
                renderGeneratedGoalsReview();
                goalGeneratorModal.classList.remove('hidden');
            });
            closeGoalGeneratorBtn.addEventListener('click', () => goalGeneratorModal.classList.add('hidden'));
            goalGeneratorModal.addEventListener('click', (e) => {
                if (e.target.id === 'goalGeneratorModal') {
                    goalGeneratorModal.classList.add('hidden');
                }
            });
            runGoalGeneratorBtn.addEventListener('click', generateGoalDrafts);
            applyGeneratedGoalsBtn.addEventListener('click', applyGeneratedGoals);
            generatedGoalsReview.addEventListener('input', syncGeneratedGoalsFromReview);
            generatedGoalsReview.addEventListener('change', syncGeneratedGoalsFromReview);

            interventionBankBtn.addEventListener('click', () => {
                renderInterventionBank();
                interventionBankModal.classList.remove('hidden');
            });
            closeInterventionBankBtn.addEventListener('click', () => interventionBankModal.classList.add('hidden'));
            interventionBankModal.addEventListener('click', (e) => {
                if (e.target.id === 'interventionBankModal') {
                    interventionBankModal.classList.add('hidden');
                }
            });
            addInterventionBtn.addEventListener('click', () => {
                const text = (newInterventionInput.value || '').trim();
                if (!text) return;
                if (!Array.isArray(data.interventionBank)) data.interventionBank = [];
                if (!data.interventionBank.includes(text)) {
                    data.interventionBank.push(text);
                    data.interventionBank.sort((a, b) => a.localeCompare(b));
                    newInterventionInput.value = '';
                    markDirty();
                    renderInterventionBank();
                }
            });
            interventionBankList.addEventListener('click', (e) => {
                const btn = e.target.closest('[data-bank-index]');
                if (!btn) return;
                const index = parseInt(btn.dataset.bankIndex, 10);
                if (Number.isNaN(index)) return;
                const [removed] = data.interventionBank.splice(index, 1);
                if (removed) {
                    [...(data.clients || []), ...(data.archivedClients || [])].forEach(client => {
                        (client.appointments || []).forEach(appt => {
                            if (Array.isArray(appt.selectedInterventions)) {
                                appt.selectedInterventions = appt.selectedInterventions.filter(item => item !== removed);
                            }
                        });
                    });
                    markDirty();
                    renderInterventionBank();
                    renderSoap();
                }
            });

            closeInterventionPickerBtn.addEventListener('click', () => interventionPickerModal.classList.add('hidden'));
            interventionPickerModal.addEventListener('click', (e) => {
                if (e.target.id === 'interventionPickerModal') {
                    interventionPickerModal.classList.add('hidden');
                }
            });
            saveInterventionSelectionBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!appointment) return;
                const selected = Array.from(interventionPickerList.querySelectorAll('.picker-intervention:checked')).map(input => input.value);
                appointment.selectedInterventions = selected;
                if (!appointment.soap) appointment.soap = { s: '', o: '', a: '', p: '' };
                appointment.soap.interventions = selected.length > 0
                    ? selected.map(item => `â€¢ ${item}`).join('\n')
                    : 'No interventions selected from the bank.';
                delete appointment.auditCheck;
                markDirty();
                interventionPickerModal.classList.add('hidden');
                renderSoap();
            });
            exportBtn.addEventListener('click', exportFile);
            closeExportDataBtn.addEventListener('click', () => exportDataModal.classList.add('hidden'));
            exportDataModal.addEventListener('click', (e) => {
                if (e.target.id === 'exportDataModal') {
                    exportDataModal.classList.add('hidden');
                }
            });
            copyExportDataBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(exportDataText.value || '');
                    updateSaveStatus('Encrypted SQL export copied.', true, 2000);
                } catch (error) {
                    alert('Copy failed. Please select and copy the text manually.');
                }
            });
            downloadExportDataBtn.addEventListener('click', downloadExportData);
            importBtn.addEventListener('click', loadFile);
            eraseAllBtn.addEventListener('click', eraseAllData);
            changePasswordBtn.addEventListener('click', async () => {
                const currentPassword = (currentPasswordInput.value || '').trim();
                const newPassword = (newPasswordInput.value || '').trim();
                const confirmNewPassword = (confirmNewPasswordInput.value || '').trim();

                changePasswordStatus.textContent = '';

                if (!currentPassword || !newPassword || !confirmNewPassword) {
                    changePasswordStatus.textContent = 'Fill all password fields.';
                    changePasswordStatus.style.color = '#e74c3c';
                    return;
                }

                if (newPassword !== confirmNewPassword) {
                    changePasswordStatus.textContent = 'New passwords do not match.';
                    changePasswordStatus.style.color = '#e74c3c';
                    return;
                }

                if (newPassword.length < 8) {
                    changePasswordStatus.textContent = 'New password must be at least 8 chars.';
                    changePasswordStatus.style.color = '#e74c3c';
                    return;
                }

                changePasswordBtn.disabled = true;
                changePasswordStatus.textContent = 'Updating...';
                changePasswordStatus.style.color = '#f39c12';

                const success = await changePassword(currentPassword, newPassword);
                if (success) {
                    currentPasswordInput.value = '';
                    newPasswordInput.value = '';
                    confirmNewPasswordInput.value = '';
                    changePasswordStatus.textContent = 'Password updated.';
                    changePasswordStatus.style.color = '#27ae60';
                } else {
                    changePasswordStatus.textContent = 'Password update failed.';
                    changePasswordStatus.style.color = '#e74c3c';
                }
                changePasswordBtn.disabled = false;
            });
            generateNoteBtn.addEventListener('click', generateSoapNote);
            connectApiBtn.addEventListener('click', connectToServer);
            verifyApiBtn.addEventListener('click', verifyApiConnection);
            
            selectVertexKeyBtn.addEventListener('click', () => {
                vertexKeyFileInput.click();
            });
            
            clearVertexKeyBtn.addEventListener('click', () => {
                vertexServiceAccountInput.value = '';
                localStorage.removeItem('vertexServiceAccount');
                vertexKeyStatus.textContent = 'No file selected';
                vertexKeyStatus.style.color = 'var(--text-color-secondary)';
                clearVertexKeyBtn.classList.add('hidden');
                vertexModelInput.innerHTML = '<option>Connect first</option>';
                vertexModelInput.disabled = true;
                apiStatus.textContent = '';
            });
            
            vertexKeyFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const jsonContent = event.target.result;
                        const parsed = JSON.parse(jsonContent);
                        
                        if (!parsed.project_id || !parsed.client_email || !parsed.private_key) {
                            throw new Error('Invalid Service Account JSON. Missing required fields.');
                        }
                        
                        vertexServiceAccountInput.value = jsonContent;
                        vertexKeyStatus.textContent = file.name;
                        vertexKeyStatus.style.color = '#27ae60';
                        clearVertexKeyBtn.classList.remove('hidden');
                        
                        // Auto-save to localStorage
                        localStorage.setItem('vertexServiceAccount', jsonContent);
                        
                    } catch (err) {
                        alert('Error parsing JSON file: ' + err.message);
                        vertexKeyStatus.textContent = 'Invalid file';
                        vertexKeyStatus.style.color = '#e74c3c';
                        clearVertexKeyBtn.classList.add('hidden');
                        vertexServiceAccountInput.value = '';
                    }
                };
                reader.readAsText(file);
                // Reset input so the same file can be selected again if needed
                e.target.value = '';
            });

            manualSaveBtn.addEventListener('click', () => {
                saveDataToLocalStorage();
                updateSaveStatus('Data saved!', true, 2000);
            });

            const closeHeaderMenu = () => {
                if (headerMenuDropdown) headerMenuDropdown.classList.add('hidden');
            };

            if (headerMenuBtn && headerMenuDropdown) {
                headerMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    headerMenuDropdown.classList.toggle('hidden');
                });
                document.addEventListener('click', (e) => {
                    if (!headerMenu || !headerMenu.contains(e.target)) {
                        closeHeaderMenu();
                    }
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeHeaderMenu();
                });
            }

            [
                informedConsentBtn,
                cssrsBtn,
                soapAuditGuideBtn,
                interventionBankBtn,
                configureBackupBtn,
                clearBackupBtn,
                manualSaveBtn,
                settingsBtn,
                checkForUpdatesBtn,
                lockScreenBtn
            ].filter(Boolean).forEach(btn => {
                btn.addEventListener('click', () => {
                    closeHeaderMenu();
                });
            });

            configureBackupBtn?.addEventListener('click', configureSecondaryBackupLocation);
            clearBackupBtn?.addEventListener('click', clearSecondaryBackupLocation);

            settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
            
            checkForUpdatesBtn?.addEventListener('click', async () => {
                try {
                    const update = await check();
                    if (update) {
                        const yes = await ask(`Update to ${update.version} is available!\n\nRelease notes: ${update.body}\n\nDo you want to download and install it now?`, {
                            title: 'Update Available',
                            kind: 'info',
                        });
                        if (yes) {
                            let downloaded = 0;
                            let contentLength = 0;
                            await update.downloadAndInstall((event) => {
                                switch (event.event) {
                                    case 'Started':
                                        contentLength = event.data.contentLength;
                                        console.log(`started downloading ${event.data.contentLength} bytes`);
                                        break;
                                    case 'Progress':
                                        downloaded += event.data.chunkLength;
                                        console.log(`downloaded ${downloaded} from ${contentLength}`);
                                        break;
                                    case 'Finished':
                                        console.log('download finished');
                                        break;
                                }
                            });
                            
                            const restart = await ask('Update installed successfully. Do you want to restart the app now?', {
                                title: 'Restart Required',
                                kind: 'info',
                            });
                            if (restart) {
                                await relaunch();
                            }
                        }
                    } else {
                        await message('You are on the latest version.', { title: 'No Updates Available', kind: 'info' });
                    }
                } catch (error) {
                    console.error('Failed to check for updates:', error);
                    await message(`Failed to check for updates: ${error.message || error}`, { title: 'Error', kind: 'error' });
                }
            });

            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
            lockScreenBtn.addEventListener('click', () => lockApp());
            settingsModal.addEventListener('click', (e) => {
                if(e.target.id === 'settingsModal') {
                    settingsModal.classList.add('hidden');
                }
            });

            informedConsentBtn.addEventListener('click', () => informedConsentModal.classList.remove('hidden'));
            closeConsentBtn.addEventListener('click', () => informedConsentModal.classList.add('hidden'));
            closeConsentBtnBottom.addEventListener('click', () => informedConsentModal.classList.add('hidden'));
            informedConsentModal.addEventListener('click', (e) => {
                if(e.target.id === 'informedConsentModal') {
                    informedConsentModal.classList.add('hidden');
                }
            });
            soapAuditGuideBtn.addEventListener('click', () => soapAuditGuideModal.classList.remove('hidden'));
            closeSoapAuditGuideBtn.addEventListener('click', () => soapAuditGuideModal.classList.add('hidden'));
            closeSoapAuditGuideBtnBottom.addEventListener('click', () => soapAuditGuideModal.classList.add('hidden'));
            soapAuditGuideModal.addEventListener('click', (e) => {
                if (e.target.id === 'soapAuditGuideModal') {
                    soapAuditGuideModal.classList.add('hidden');
                }
            });
            customInstructionsBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                const clientLens = getClientGoalGenerationLens(client);
                goalGeneratorModalities = [...clientLens.modalities];
                goalGeneratorModalityOther = clientLens.other || '';
                persistentInstructions = client ? client.persistentInstructions || '' : '';
                sessionInstructions = appointment ? appointment.sessionInstructions || '' : '';
                customInstructionsModal.classList.remove('hidden');
                persistentInstructionsInput.value = persistentInstructions;
                sessionInstructionsInput.value = sessionInstructions;
                sessionInstructionsInput.disabled = !appointment;
                sessionInstructionsInput.placeholder = appointment
                    ? 'Applies only to the selected appointment/session.'
                    : 'Select an appointment to edit Session Instructions.';
                renderCustomInstructionsModalities();
                persistentInstructionsInput.focus();
            });
            closeCustomInstructionsBtn.addEventListener('click', () => customInstructionsModal.classList.add('hidden'));
            customInstructionsModal.addEventListener('click', (e) => {
                if(e.target.id === 'customInstructionsModal') {
                    customInstructionsModal.classList.add('hidden');
                }
            });
            saveCustomInstructionsBtn.addEventListener('click', () => {
                persistentInstructions = persistentInstructionsInput.value;
                sessionInstructions = sessionInstructionsInput.value;
                customInstructionsModal.classList.add('hidden');
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (client) {
                    client.persistentInstructions = persistentInstructions;
                }
                if (appointment) {
                    appointment.sessionInstructions = sessionInstructions;
                    if (!appointment.sessionInstructions.trim()) delete appointment.sessionInstructions;
                    if (appointment.customInstructions !== undefined) delete appointment.customInstructions;
                }
                markDirty();
            });
            clearCustomInstructionsBtn.addEventListener('click', () => {
                persistentInstructionsInput.value = '';
                sessionInstructionsInput.value = '';
                persistentInstructions = '';
                sessionInstructions = '';
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (client) {
                    client.persistentInstructions = '';
                }
                if (appointment) {
                    delete appointment.sessionInstructions;
                    if (appointment.customInstructions !== undefined) delete appointment.customInstructions;
                }
                markDirty();
            });
            customInstructionsModalitiesListEl.addEventListener('change', (e) => {
                if (!e.target.matches('.custom-instructions-modality-select')) return;
                saveCustomInstructionsModalities();
            });
            customInstructionsModalitiesListEl.addEventListener('click', (e) => {
                if (e.target.classList.contains('add-custom-modality-btn')) {
                    goalGeneratorModalities.push(DEFAULT_GUIDING_MODALITIES[0]);
                    renderCustomInstructionsModalities();
                    saveClientGoalGenerationLens();
                    return;
                }
                if (e.target.classList.contains('remove-custom-modality-btn')) {
                    if (goalGeneratorModalities.length <= 1) return;
                    const row = e.target.closest('.modality-row');
                    const index = row ? parseInt(row.dataset.modalInstructionsIndex, 10) : -1;
                    if (index >= 0) {
                        goalGeneratorModalities.splice(index, 1);
                        if (!goalGeneratorModalities.includes('Other (Specify)')) {
                            goalGeneratorModalityOther = '';
                        }
                        renderCustomInstructionsModalities();
                        saveClientGoalGenerationLens();
                    }
                }
            });
            customInstructionsModalityOtherEl.addEventListener('input', () => {
                goalGeneratorModalityOther = customInstructionsModalityOtherEl.value;
                saveClientGoalGenerationLens();
            });
            modelSelect.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                if (apiProvider === 'openwebui') {
                    localStorage.setItem('openWebUIModel', selectedModel);
                } else if (apiProvider === 'ollama') {
                    localStorage.setItem('ollamaModel', selectedModel);
                }
                fullRender();
            });

            openaiModelInput.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('openaiModel', selectedModel);
                fullRender();
            });

            vertexModelInput.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('vertexModel', selectedModel);
                fullRender();
            });

            const toggleProviderSettings = () => {
                const provider = apiProviderSelect.value;
                apiProvider = provider;
                openwebuiSettings.classList.add('hidden');
                if (ollamaSettings) ollamaSettings.classList.add('hidden');
                vertexSettings.classList.add('hidden');
                openaiSettings.classList.add('hidden');
                modelSelectWrapper.classList.add('hidden'); // This is for OpenWebUI/Ollama

                if (provider === 'openwebui') {
                    openwebuiSettings.classList.remove('hidden');
                    modelSelectWrapper.classList.remove('hidden'); // Show the OpenWebUI model select
                } else if (provider === 'ollama') {
                    if (ollamaSettings) ollamaSettings.classList.remove('hidden');
                    modelSelectWrapper.classList.remove('hidden'); // Ollama also uses the shared model select
                } else if (provider === 'vertex') {
                    vertexSettings.classList.remove('hidden');
                } else if (provider === 'openai') {
                    openaiSettings.classList.remove('hidden');
                }
            };
            apiProviderSelect.addEventListener('change', toggleProviderSettings);

            startTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment) {
                    appointment.startTime = new Date().toISOString();
                    appointment.endTime = null; // Clear end time if starting again
                    delete appointment.auditCheck;
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            stopTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment && appointment.startTime) { // Can only stop if started
                    appointment.endTime = new Date().toISOString();
                    clearInterval(sessionTimerInterval);
                    delete appointment.auditCheck;
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            // --- Theme Management ---
            const updateThemeButton = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                if (savedTheme === 'dark') {
                    themeToggleBtn.textContent = 'ðŸŒ™';
                    themeToggleBtn.title = 'Switch to Automatic Theme';
                } else if (savedTheme === 'automatic') {
                    themeToggleBtn.textContent = 'ðŸ”„';
                    themeToggleBtn.title = 'Switch to Light Theme';
                } else {
                    themeToggleBtn.textContent = 'â˜€ï¸';
                    themeToggleBtn.title = 'Switch to Dark Theme';
                }
            };

            const cycleTheme = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                let newTheme;
                if (savedTheme === 'light') {
                    newTheme = 'dark';
                } else if (savedTheme === 'dark') {
                    newTheme = 'automatic';
                } else {
                    newTheme = 'light';
                }
                applyTheme(newTheme);
            };

            const applyTheme = (theme) => {
                if (theme === 'automatic') {
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    document.body.dataset.theme = prefersDark ? 'dark' : 'light';
                } else {
                    document.body.dataset.theme = theme;
                }
                localStorage.setItem('theme', theme);
                updateThemeButton();
            };

            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                if (savedTheme === 'automatic') {
                    applyTheme('automatic');
                }
            });

            themeToggleBtn.addEventListener('click', cycleTheme);

            // --- Collapsible Sections ---
            const handleCollapsibleClick = (e) => {
                const header = e.target.closest('.collapsible-header');
                if (!header) return;

                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                const icon = header.querySelector('.collapse-icon');
                const wrapper = header.parentElement;

                if (content && icon) {
                    const isCollapsed = content.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        // Expand - restore original size and remove pinning
                        content.classList.remove('collapsed', 'pinned');
                        icon.classList.remove('collapsed');
                        wrapper.style.flexBasis = '33.33%';
                        wrapper.style.minHeight = '';
                        wrapper.style.maxHeight = '';
                        wrapper.style.order = ''; // Reset order
                    } else {
                        // Collapse - add pinning class and force minimal size
                        content.classList.add('collapsed', 'pinned');
                        icon.classList.add('collapsed');
                        wrapper.style.flexBasis = '50px';
                        wrapper.style.minHeight = '50px';
                        wrapper.style.maxHeight = '50px';
                        // Order is now handled by CSS class
                        wrapper.style.order = ''; // Clear inline order to let CSS handle it
                    }
                    
                    // Save collapsed state
                    const sectionName = targetId.replace('Content', '');
                    localStorage.setItem(`${sectionName}Collapsed`, !isCollapsed);
                    saveColumnSizes(); // Update saved sizes
                }
            };

            // Add event listeners for collapsible headers
            document.addEventListener('click', handleCollapsibleClick);

            // Load collapsed states
            const loadCollapsedStates = () => {
                const notesCollapsed = localStorage.getItem('notesCollapsed') === 'true';

                if (notesCollapsed) {
                    const notesContent = document.getElementById('notesContent');
                    const notesIcon = document.querySelector('[data-target="notesContent"] .collapse-icon');
                    const notesWrapper = document.getElementById('notesWrapper');
                    
                    notesContent?.classList.add('collapsed', 'pinned');
                    notesIcon?.classList.add('collapsed');
                    if (notesWrapper) {
                        notesWrapper.style.flexBasis = '50px';
                        notesWrapper.style.minHeight = '50px';
                        notesWrapper.style.maxHeight = '50px';
                        notesWrapper.style.order = ''; // Clear order to let CSS handle it
                    }
                }
            };

            // --- Resizable Panels ---
            function saveColumnSizes() {
                const panels = ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'];
                const sizes = panels.map(id => document.getElementById(id).style.flexBasis);
                localStorage.setItem('columnSizes', JSON.stringify(sizes));
                const sessionInfoHeight = document.getElementById('sessionInfoWrapper').style.flexBasis;
                const notesHeight = document.getElementById('notesWrapper').style.flexBasis;
                localStorage.setItem('rowSizes', JSON.stringify({ sessionInfoHeight, notesHeight }));
            }

            function loadColumnSizes() {
                const sizes = JSON.parse(localStorage.getItem('columnSizes'));
                if (sizes && sizes.length === 4) {
                    ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'].forEach((id, index) => {
                        const panel = document.getElementById(id);
                        if (panel) panel.style.flexBasis = sizes[index];
                    });
                }
                const rowSizes = JSON.parse(localStorage.getItem('rowSizes'));
                if (rowSizes) {
                    const sessionWrapper = document.getElementById('sessionInfoWrapper');
                    const notesWrapper = document.getElementById('notesWrapper');
                    if (sessionWrapper) sessionWrapper.style.flexBasis = rowSizes.sessionInfoHeight;
                    if (notesWrapper) notesWrapper.style.flexBasis = rowSizes.notesHeight;
                }
            }

            function makeResizable(resizer, prev, next, direction = 'x') {
                let x = 0;
                let y = 0;
                let prevSize = 0;
                let nextSize = 0;
                let containerSize = 0;

                resizer.addEventListener('mousedown', function (e) {
                    e.preventDefault();
                    if (direction === 'x') {
                        x = e.clientX;
                        prevSize = prev.getBoundingClientRect().width;
                        nextSize = next.getBoundingClientRect().width;
                        containerSize = prev.parentElement.getBoundingClientRect().width;
                    } else {
                        y = e.clientY;
                        prevSize = prev.getBoundingClientRect().height;
                        nextSize = next.getBoundingClientRect().height;
                        containerSize = prev.parentElement.getBoundingClientRect().height;
                    }
                    
                    document.body.style.cursor = direction === 'x' ? 'col-resize' : 'row-resize';
                    document.body.style.userSelect = 'none';

                    document.addEventListener('mousemove', mousemove);
                    document.addEventListener('mouseup', mouseup);
                });

                function mousemove(e) {
                    if (direction === 'x') {
                        const dx = e.clientX - x;
                        const newPrevSize = prevSize + dx;
                        const newNextSize = nextSize - dx;
                        
                        if(newPrevSize > 150 && newNextSize > 150) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    } else {
                        const dy = e.clientY - y;
                        const newPrevSize = prevSize + dy;
                        const newNextSize = nextSize - dy;

                        if(newPrevSize > 100 && newNextSize > 100) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    }
                }

                function mouseup() {
                    document.removeEventListener('mousemove', mousemove);
                    document.removeEventListener('mouseup', mouseup);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                    saveColumnSizes();
                }
            }
            
            // --- Initial Load & Render ---
            const loadServerSettings = () => {
                const savedProvider = localStorage.getItem('apiProvider');
                if (savedProvider) {
                    apiProvider = savedProvider;
                    apiProviderSelect.value = apiProvider;
                }
                
                const savedAddress = localStorage.getItem('serverAddress');
                const savedApiKey = localStorage.getItem('apiKey');
                const savedVertexServiceAccount = localStorage.getItem('vertexServiceAccount');
                const savedVertexLocation = localStorage.getItem('vertexLocation');
                const savedOpenAIKey = localStorage.getItem('openaiApiKey');
                const savedOllamaAddress = localStorage.getItem('ollamaAddress');
                
                toggleProviderSettings(); // Set initial UI state

                if (apiProvider === 'openwebui' && savedAddress) {
                    serverAddressInput.value = savedAddress;
                    if (savedApiKey) apiKeyInput.value = savedApiKey;
                    connectToOpenWebUI();
                } else if (apiProvider === 'vertex' && savedVertexServiceAccount) {
                    vertexServiceAccountInput.value = savedVertexServiceAccount;
                    vertexKeyStatus.textContent = 'Key loaded from storage';
                    vertexKeyStatus.style.color = '#27ae60';
                    clearVertexKeyBtn.classList.remove('hidden');
                    vertexLocationInput.value = savedVertexLocation || 'us-central1';
                    connectToVertex();
                } else if (apiProvider === 'openai' && savedOpenAIKey) {
                    openaiApiKeyInput.value = savedOpenAIKey;
                    connectToOpenAI();
                } else if (apiProvider === 'ollama' && savedOllamaAddress && ollamaAddressInput) {
                    ollamaAddressInput.value = savedOllamaAddress;
                    connectToOllama();
                }
            };
            
            const loadTheme = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                applyTheme(savedTheme);
            };

            // Set appointment date to today (local timezone, not UTC)
            const today = new Date();
            const localDateString = today.getFullYear() + '-' + 
                String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                String(today.getDate()).padStart(2, '0');
            appointmentDateInput.value = localDateString;
            
            // Data loading is now handled by unlockApp()
            
            loadServerSettings();
            loadColumnSizes();
            loadCollapsedStates();
            loadTheme();
            
            makeResizable(document.getElementById('resizer1'), document.getElementById('panelClients'), document.getElementById('panelAppointments'));
            makeResizable(document.getElementById('resizer2'), document.getElementById('panelAppointments'), document.getElementById('panelSession'));
            makeResizable(document.getElementById('resizer3'), document.getElementById('panelSession'), document.getElementById('panelSoap'));
            makeResizable(document.getElementById('resizer-session-notes'), document.getElementById('sessionInfoWrapper'), document.getElementById('notesWrapper'), 'y');

            window.__appAuthHooks = {
                loadDataFromLocalStorage,
                normalizeClientData,
                fullRender
            };

        });

        // --- Login and Auto-Lock Logic ---
        let inactivityTimer;
        const INACTIVITY_LIMIT = 10 * 60 * 1000; // 10 minutes

        function showVerificationPanel(username = '') {
            const verifyPanel = document.getElementById('verifyEmailPanel');
            const resetPanel = document.getElementById('resetPanel');
            const smtpPanel = document.getElementById('smtpSettingsPanel');
            const deletePanel = document.getElementById('deleteAccountPanel');
            verifyPanel.style.display = 'block';
            resetPanel.style.display = 'none';
            smtpPanel.style.display = 'none';
            deletePanel.style.display = 'none';
            if (username) {
                document.getElementById('loginUsernameInput').value = username.trim();
            }
            document.getElementById('verifyEmailStatusMsg').textContent = '';
        }

        async function showSmtpSettingsPanel(username = '') {
            const panel = document.getElementById('smtpSettingsPanel');
            document.getElementById('loginToolsDropdown').classList.add('hidden');
            document.getElementById('resetPanel').style.display = 'none';
            document.getElementById('verifyEmailPanel').style.display = 'none';
            document.getElementById('deleteAccountPanel').style.display = 'none';
            panel.style.display = 'block';

            const normalizedUsername = (username || document.getElementById('loginUsernameInput').value || '').trim();
            document.getElementById('smtpUpdateUsernameInput').value = normalizedUsername;
            document.getElementById('smtpUpdateHostInput').value = 'smtp.gmail.com';
            document.getElementById('smtpUpdatePortInput').value = '587';
            document.getElementById('smtpUpdateSecurityInput').value = 'starttls';
            document.getElementById('smtpSettingsStatusMsg').textContent = '';

            const loginPassword = document.getElementById('loginPasswordInput').value || '';
            if (normalizedUsername && loginPassword) {
                const settings = await getRecoverySettings(normalizedUsername, loginPassword);
                if (settings) {
                    document.getElementById('smtpUpdateRecoveryEmailInput').value = settings.email || '';
                    document.getElementById('smtpUpdateHostInput').value = settings.smtpHost || 'smtp.gmail.com';
                    document.getElementById('smtpUpdatePortInput').value = String(settings.smtpPort || 587);
                    document.getElementById('smtpUpdateSecurityInput').value = ['tls', 'ssl', 'starttls'].includes((settings.smtpSecurity || '').toLowerCase())
                        ? (settings.smtpSecurity || '').toLowerCase()
                        : 'starttls';
                    document.getElementById('smtpUpdateUsernameSmtpInput').value = settings.smtpUsername || '';
                    document.getElementById('smtpUpdateFromInput').value = settings.smtpFrom || settings.email || '';
                    document.getElementById('smtpSettingsStatusMsg').style.color = 'var(--text-color-secondary)';
                    document.getElementById('smtpSettingsStatusMsg').textContent = 'Loaded saved SMTP settings. Enter SMTP app password to test/save.';
                } else {
                    document.getElementById('smtpUpdateRecoveryEmailInput').value = document.getElementById('onboardingEmailInput').value || '';
                    document.getElementById('smtpUpdateFromInput').value = document.getElementById('smtpUpdateRecoveryEmailInput').value || '';
                    document.getElementById('smtpSettingsStatusMsg').style.color = '#e67e22';
                    document.getElementById('smtpSettingsStatusMsg').textContent = getLastAuthError() || 'Enter current password to load saved SMTP fields.';
                }
            } else {
                document.getElementById('smtpUpdateRecoveryEmailInput').value = document.getElementById('onboardingEmailInput').value || '';
                document.getElementById('smtpUpdateFromInput').value = document.getElementById('smtpUpdateRecoveryEmailInput').value || '';
            }

            document.getElementById('smtpUpdatePasswordSmtpInput').value = '';
        }

        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(lockApp, INACTIVITY_LIMIT);
        }

        function lockApp() {
            document.getElementById('loginOverlay').style.display = 'flex';
            document.getElementById('appContainer').style.display = 'none';
            document.getElementById('loginUsernameInput').value = '';
            document.getElementById('loginPasswordInput').value = '';
            document.getElementById('loginErrorMsg').style.display = 'none';
            document.getElementById('resetPanel').style.display = 'none';
            document.getElementById('verifyEmailPanel').style.display = 'none';
            document.getElementById('smtpSettingsPanel').style.display = 'none';
            document.getElementById('deleteAccountPanel').style.display = 'none';
            document.getElementById('loginToolsDropdown').classList.add('hidden');
            // Clear sensitive data from memory if needed
            initLoginScreen(); // Re-check if it's still the first login
        }

        let isFirstLogin = false;

        async function initLoginScreen() {
            isFirstLogin = await checkFirstLogin();
            const authError = getLastAuthError();
            const onboardingRecoverySection = document.getElementById('onboardingRecoverySection');
            const forgotPasswordBtn = document.getElementById('forgotPasswordBtn');
            const resetPanel = document.getElementById('resetPanel');
            const verifyEmailPanel = document.getElementById('verifyEmailPanel');
            const smtpSettingsPanel = document.getElementById('smtpSettingsPanel');
            const loginToolsMenu = document.getElementById('loginToolsMenu');
            const deleteAccountPanel = document.getElementById('deleteAccountPanel');
            if (authError) {
                const hint = authError.includes('window.__TAURI_INTERNALS__') || authError.includes('invoke')
                    ? 'Open the desktop app window (Tauri), not the browser URL.'
                    : '';
                document.getElementById('loginErrorMsg').textContent = hint ? `${authError} ${hint}` : authError;
                document.getElementById('loginErrorMsg').style.display = 'block';
            } else {
                document.getElementById('loginErrorMsg').style.display = 'none';
            }
            if (isFirstLogin) {
                document.getElementById('loginTitle').textContent = "Create Account";
                document.getElementById('loginSubtitle').textContent = "Create a username/password and recovery email + SMTP settings.";
                document.getElementById('loginBtn').textContent = "Create Account";
                onboardingRecoverySection.style.display = 'block';
                forgotPasswordBtn.style.display = 'none';
                loginToolsMenu.style.display = 'none';
                resetPanel.style.display = 'none';
                verifyEmailPanel.style.display = 'none';
                smtpSettingsPanel.style.display = 'none';
                deleteAccountPanel.style.display = 'none';
            } else {
                document.getElementById('loginTitle').textContent = "Client Records Login";
                document.getElementById('loginSubtitle').textContent = "Enter your username and password to unlock the database.";
                document.getElementById('loginBtn').textContent = "Unlock";
                onboardingRecoverySection.style.display = 'none';
                forgotPasswordBtn.style.display = 'block';
                loginToolsMenu.style.display = 'block';
                resetPanel.style.display = 'none';
                verifyEmailPanel.style.display = 'none';
                smtpSettingsPanel.style.display = 'none';
                deleteAccountPanel.style.display = 'none';
            }
        }

        async function unlockApp() {
            const username = document.getElementById('loginUsernameInput').value;
            const password = document.getElementById('loginPasswordInput').value;
            
            if (username && password) {
                let success = false;
                if (isFirstLogin) {
                    const recoveryEmail = document.getElementById('onboardingEmailInput').value;
                    const smtpHost = document.getElementById('onboardingSmtpHostInput').value;
                    const smtpPort = document.getElementById('onboardingSmtpPortInput').value;
                    const smtpSecurity = document.getElementById('onboardingSmtpSecurityInput').value;
                    const smtpUsername = document.getElementById('onboardingSmtpUsernameInput').value;
                    const smtpPassword = document.getElementById('onboardingSmtpPasswordInput').value;
                    const smtpFrom = document.getElementById('onboardingSmtpFromInput').value;
                    success = await createUser(username, password, recoveryEmail, {
                        smtpHost,
                        smtpPort,
                        smtpSecurity,
                        smtpUsername,
                        smtpPassword,
                        smtpFrom
                    });

                    if (success) {
                        showVerificationPanel(username);
                        const verifyStatus = document.getElementById('verifyEmailStatusMsg');
                        verifyStatus.style.color = '#27ae60';
                        verifyStatus.textContent = 'Verification code sent. Enter it below to finish setup.';
                        document.getElementById('loginErrorMsg').style.display = 'none';
                        return;
                    }
                } else {
                    success = await loginUser(username, password);

                    if (!success) {
                        const authError = getLastAuthError() || '';
                        if (authError.toLowerCase().includes('email not verified')) {
                            showVerificationPanel(username);
                            const verifyStatus = document.getElementById('verifyEmailStatusMsg');
                            verifyStatus.style.color = '#e67e22';
                            verifyStatus.textContent = 'Email not verified. Send or enter your verification code.';
                        }
                    }
                }

                if (success) {
                    try {
                        const hooks = window.__appAuthHooks;
                        if (!hooks) {
                            throw new Error('Application is not initialized yet.');
                        }

                        // Try to load data to verify password
                        await hooks.loadDataFromLocalStorage();
                        
                        document.getElementById('loginOverlay').style.display = 'none';
                        document.getElementById('appContainer').style.display = 'flex';
                        resetInactivityTimer();
                        
                        // Re-render after loading data
                        hooks.normalizeClientData();
                        hooks.fullRender();
                    } catch (e) {
                        document.getElementById('loginErrorMsg').textContent = "Incorrect username, password, or corrupted data.";
                        document.getElementById('loginErrorMsg').style.display = 'block';
                    }
                } else {
                    const authError = getLastAuthError();
                    document.getElementById('loginErrorMsg').textContent = authError || (isFirstLogin ? "Failed to create user." : "Incorrect username or password.");
                    document.getElementById('loginErrorMsg').style.display = 'block';
                    if (isFirstLogin && authError && authError.includes('already exists')) {
                        await initLoginScreen();
                    }
                }
            } else {
                document.getElementById('loginErrorMsg').textContent = "Please enter a username and password.";
                document.getElementById('loginErrorMsg').style.display = 'block';
            }
        }

        document.getElementById('loginBtn').addEventListener('click', unlockApp);
        document.getElementById('loginPasswordInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') unlockApp();
        });
        document.getElementById('loginUsernameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('loginPasswordInput').focus();
        });

        document.getElementById('forgotPasswordBtn').addEventListener('click', () => {
            const resetPanel = document.getElementById('resetPanel');
            const usernameInput = document.getElementById('loginUsernameInput');
            const resetUsernameInput = document.getElementById('resetUsernameInput');
            resetPanel.style.display = resetPanel.style.display === 'none' ? 'block' : 'none';
            document.getElementById('verifyEmailPanel').style.display = 'none';
            document.getElementById('smtpSettingsPanel').style.display = 'none';
            document.getElementById('deleteAccountPanel').style.display = 'none';
            resetUsernameInput.value = (usernameInput.value || '').trim();
            document.getElementById('resetStatusMsg').textContent = '';
        });

        document.getElementById('openSmtpPanelBtn').addEventListener('click', async () => {
            await showSmtpSettingsPanel();
        });

        document.getElementById('openSmtpPanelFromVerifyBtn').addEventListener('click', async () => {
            const username = (document.getElementById('loginUsernameInput').value || '').trim();
            await showSmtpSettingsPanel(username);
        });

        document.getElementById('cancelResetBtn').addEventListener('click', () => {
            document.getElementById('resetPanel').style.display = 'none';
            document.getElementById('resetStatusMsg').textContent = '';
        });

        document.getElementById('loginToolsBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('loginToolsDropdown');
            dropdown.classList.toggle('hidden');
        });

        document.addEventListener('click', (e) => {
            const menu = document.getElementById('loginToolsMenu');
            if (!menu.contains(e.target)) {
                document.getElementById('loginToolsDropdown').classList.add('hidden');
            }
        });

        document.getElementById('openDeleteAccountPanelBtn').addEventListener('click', () => {
            document.getElementById('loginToolsDropdown').classList.add('hidden');
            document.getElementById('resetPanel').style.display = 'none';
            document.getElementById('verifyEmailPanel').style.display = 'none';
            document.getElementById('smtpSettingsPanel').style.display = 'none';
            const panel = document.getElementById('deleteAccountPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            document.getElementById('deleteAccountStatusMsg').textContent = '';
            document.getElementById('deleteAccountUsernameInput').value = (document.getElementById('loginUsernameInput').value || '').trim();
        });

        // Auto-suggest port when security mode changes
        function suggestPortForSecurity(securityValue, portInput) {
            const currentPort = Number(portInput.value);
            if (securityValue === 'tls' || securityValue === 'ssl') {
                if (currentPort === 587 || currentPort === 25 || !currentPort) {
                    portInput.value = '465';
                }
            } else if (securityValue === 'starttls') {
                if (currentPort === 465 || currentPort === 25 || !currentPort) {
                    portInput.value = '587';
                }
            }
        }

        document.getElementById('smtpUpdateSecurityInput').addEventListener('change', (e) => {
            suggestPortForSecurity(e.target.value, document.getElementById('smtpUpdatePortInput'));
        });

        document.getElementById('onboardingSmtpSecurityInput').addEventListener('change', (e) => {
            suggestPortForSecurity(e.target.value, document.getElementById('onboardingSmtpPortInput'));
        });

        // Validate port/security match and warn user
        function validatePortSecurityMatch(security, port) {
            // Allow any port/security combination - providers vary
            return '';
        }

        document.getElementById('saveSmtpSettingsBtn').addEventListener('click', async () => {
            const username = (document.getElementById('smtpUpdateUsernameInput').value || '').trim();
            const password = document.getElementById('smtpUpdatePasswordInput').value || '';
            const recoveryEmail = (document.getElementById('smtpUpdateRecoveryEmailInput').value || '').trim();
            const smtpHost = (document.getElementById('smtpUpdateHostInput').value || '').trim();
            const smtpPort = document.getElementById('smtpUpdatePortInput').value;
            const smtpSecurity = document.getElementById('smtpUpdateSecurityInput').value;
            const smtpUsername = (document.getElementById('smtpUpdateUsernameSmtpInput').value || '').trim();
            const smtpPassword = document.getElementById('smtpUpdatePasswordSmtpInput').value || '';
            const smtpFrom = (document.getElementById('smtpUpdateFromInput').value || '').trim();
            const status = document.getElementById('smtpSettingsStatusMsg');

            // Warn about port/security mismatch
            const mismatchWarning = validatePortSecurityMatch(smtpSecurity, smtpPort);
            if (mismatchWarning) {
                status.style.color = '#e67e22';
                status.textContent = mismatchWarning;
                return;
            }

            status.style.color = 'var(--text-color-secondary)';
            status.textContent = 'Saving SMTP settings and sending verification code...';

            const success = await updateRecoverySettings(username, password, recoveryEmail, {
                smtpHost,
                smtpPort,
                smtpSecurity,
                smtpUsername,
                smtpPassword,
                smtpFrom
            }, true);

            if (!success) {
                status.style.color = '#e74c3c';
                status.textContent = getLastAuthError() || 'Failed to update SMTP settings.';
                return;
            }

            const saveMessage = getLastAuthError() || 'SMTP settings updated.';
            if (saveMessage.toLowerCase().includes('verification email failed')) {
                status.style.color = '#f39c12';
                status.textContent = saveMessage;
                return;
            }

            status.style.color = '#27ae60';
            status.textContent = saveMessage;

            document.getElementById('verifyEmailCodeInput').value = '';
            document.getElementById('verifyEmailStatusMsg').textContent = 'Settings updated. Enter your new verification code.';
            document.getElementById('verifyEmailStatusMsg').style.color = '#27ae60';
            document.getElementById('smtpSettingsPanel').style.display = 'none';
            document.getElementById('verifyEmailPanel').style.display = 'block';
        });

        document.getElementById('testSmtpSettingsBtn').addEventListener('click', async () => {
            const username = (document.getElementById('smtpUpdateUsernameInput').value || '').trim();
            const password = document.getElementById('smtpUpdatePasswordInput').value || '';
            const recoveryEmail = (document.getElementById('smtpUpdateRecoveryEmailInput').value || '').trim();
            const smtpHost = (document.getElementById('smtpUpdateHostInput').value || '').trim();
            const smtpPort = document.getElementById('smtpUpdatePortInput').value;
            const smtpSecurity = document.getElementById('smtpUpdateSecurityInput').value;
            const smtpUsername = (document.getElementById('smtpUpdateUsernameSmtpInput').value || '').trim();
            const smtpPassword = document.getElementById('smtpUpdatePasswordSmtpInput').value || '';
            const smtpFrom = (document.getElementById('smtpUpdateFromInput').value || '').trim();
            const status = document.getElementById('smtpSettingsStatusMsg');

            // Warn about port/security mismatch
            const mismatchWarning = validatePortSecurityMatch(smtpSecurity, smtpPort);
            if (mismatchWarning) {
                status.style.color = '#e67e22';
                status.textContent = mismatchWarning;
                return;
            }

            status.style.color = 'var(--text-color-secondary)';
            status.textContent = 'Sending SMTP test email...';

            const ok = await testSmtpSettings(username, password, recoveryEmail, {
                smtpHost,
                smtpPort,
                smtpSecurity,
                smtpUsername,
                smtpPassword,
                smtpFrom
            });

            if (!ok) {
                status.style.color = '#e74c3c';
                status.textContent = getLastAuthError() || 'SMTP test failed.';
                return;
            }

            status.style.color = '#27ae60';
            status.textContent = 'SMTP test email sent successfully.';
        });

        document.getElementById('cancelSmtpSettingsBtn').addEventListener('click', () => {
            document.getElementById('smtpSettingsPanel').style.display = 'none';
            document.getElementById('smtpSettingsStatusMsg').textContent = '';
        });

        document.getElementById('sendVerifyEmailCodeBtn').addEventListener('click', async () => {
            const username = (document.getElementById('loginUsernameInput').value || '').trim();
            const status = document.getElementById('verifyEmailStatusMsg');
            status.style.color = 'var(--text-color-secondary)';
            status.textContent = 'Sending verification code...';

            const success = await requestEmailVerification(username);
            if (success) {
                status.style.color = '#27ae60';
                status.textContent = getLastAuthError() || 'Verification code sent.';
            } else {
                status.style.color = '#e74c3c';
                status.textContent = getLastAuthError() || 'Failed to send verification code.';
            }
        });

        document.getElementById('confirmVerifyEmailBtn').addEventListener('click', async () => {
            const username = (document.getElementById('loginUsernameInput').value || '').trim();
            const code = (document.getElementById('verifyEmailCodeInput').value || '').trim();
            const status = document.getElementById('verifyEmailStatusMsg');

            status.style.color = 'var(--text-color-secondary)';
            status.textContent = 'Verifying email...';

            const verified = await confirmEmailVerification(username, code);
            if (!verified) {
                status.style.color = '#e74c3c';
                status.textContent = getLastAuthError() || 'Verification failed.';
                return;
            }

            status.style.color = '#27ae60';
            status.textContent = 'Email verified. Unlocking...';
            document.getElementById('loginUsernameInput').value = username;

            const password = document.getElementById('loginPasswordInput').value || '';
            if (!password) {
                status.style.color = '#27ae60';
                status.textContent = 'Email verified. Enter password and click Unlock.';
                return;
            }

            await unlockApp();
        });

        document.getElementById('cancelVerifyEmailBtn').addEventListener('click', () => {
            document.getElementById('verifyEmailPanel').style.display = 'none';
            document.getElementById('verifyEmailStatusMsg').textContent = '';
        });

        document.getElementById('cancelDeleteAccountBtn').addEventListener('click', () => {
            document.getElementById('deleteAccountPanel').style.display = 'none';
            document.getElementById('deleteAccountStatusMsg').textContent = '';
        });

        document.getElementById('confirmDeleteAccountBtn').addEventListener('click', async () => {
            const username = (document.getElementById('deleteAccountUsernameInput').value || '').trim();
            const password = document.getElementById('deleteAccountPasswordInput').value || '';
            const usernameAgain = (document.getElementById('deleteAccountConfirmUsernameInput').value || '').trim();
            const typedWord = (document.getElementById('deleteAccountTypedWordInput').value || '').trim();
            const status = document.getElementById('deleteAccountStatusMsg');

            if (!username || !password || !usernameAgain || !typedWord) {
                status.style.color = '#e74c3c';
                status.textContent = 'Complete all deletion fields.';
                return;
            }

            if (username !== usernameAgain) {
                status.style.color = '#e74c3c';
                status.textContent = 'Username confirmation does not match.';
                return;
            }

            if (typedWord !== 'DELETE ACCOUNT') {
                status.style.color = '#e74c3c';
                status.textContent = 'You must type DELETE ACCOUNT exactly.';
                return;
            }

            const secondConfirmation = confirm('Final confirmation: This will permanently delete this account and local encrypted data. Continue?');
            if (!secondConfirmation) {
                status.style.color = 'var(--text-color-secondary)';
                status.textContent = 'Deletion cancelled.';
                return;
            }

            status.style.color = 'var(--text-color-secondary)';
            status.textContent = 'Deleting account...';

            const success = await deleteUserAccount(username, password);
            if (success) {
                status.style.color = '#27ae60';
                status.textContent = 'Account deleted. You can now create a fresh account.';

                document.getElementById('deleteAccountPasswordInput').value = '';
                document.getElementById('deleteAccountConfirmUsernameInput').value = '';
                document.getElementById('deleteAccountTypedWordInput').value = '';
                document.getElementById('resetPanel').style.display = 'none';

                await initLoginScreen();
            } else {
                status.style.color = '#e74c3c';
                status.textContent = getLastAuthError() || 'Account deletion failed.';
            }
        });

        document.getElementById('sendResetCodeBtn').addEventListener('click', async () => {
            const username = (document.getElementById('resetUsernameInput').value || '').trim();
            const status = document.getElementById('resetStatusMsg');
            status.style.color = 'var(--text-color-secondary)';
            status.textContent = 'Sending reset code...';
            const success = await requestPasswordReset(username);
            if (success) {
                status.style.color = '#27ae60';
                status.textContent = getLastAuthError() || 'Reset code sent.';
            } else {
                status.style.color = '#e74c3c';
                status.textContent = getLastAuthError() || 'Failed to send reset code.';
            }
        });

        document.getElementById('confirmResetBtn').addEventListener('click', async () => {
            const username = (document.getElementById('resetUsernameInput').value || '').trim();
            const code = (document.getElementById('resetCodeInput').value || '').trim();
            const newPassword = document.getElementById('resetNewPasswordInput').value || '';
            const confirmPassword = document.getElementById('resetConfirmPasswordInput').value || '';
            const status = document.getElementById('resetStatusMsg');

            if (newPassword !== confirmPassword) {
                status.style.color = '#e74c3c';
                status.textContent = 'Passwords do not match.';
                return;
            }

            status.style.color = 'var(--text-color-secondary)';
            status.textContent = 'Resetting password...';

            const success = await confirmPasswordReset(username, code, newPassword);
            if (success) {
                status.style.color = '#27ae60';
                status.textContent = 'Password reset successful. You can now log in.';
                document.getElementById('loginUsernameInput').value = username;
                document.getElementById('loginPasswordInput').value = '';
                document.getElementById('resetCodeInput').value = '';
                document.getElementById('resetNewPasswordInput').value = '';
                document.getElementById('resetConfirmPasswordInput').value = '';
            } else {
                status.style.color = '#e74c3c';
                status.textContent = getLastAuthError() || 'Password reset failed.';
            }
        });

        // Initialize login screen
        initLoginScreen();

        // Reset timer on user activity
        ['mousemove', 'keydown', 'scroll', 'click'].forEach(event => {
            document.addEventListener(event, () => {
                if (document.getElementById('appContainer').style.display === 'flex') {
                    resetInactivityTimer();
                }
            });
        });

    </script>
    </div> <!-- Close container -->
</body>
</html>

